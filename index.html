<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Custom Coasters — Designer</title>
  <style>
    :root{
      --bg:#fbf6ee;
      --ink:#1f1a15;
      --muted:#6b5f55;
      --card:#fffaf2;
      --line:#e7dccf;
      --shadow:0 12px 28px rgba(31,26,21,.10);
      --accent:#c65a2e;
      --chip:#f3e7d8;
      --focus:0 0 0 3px rgba(198,90,46,.22);
      --radius2:24px;
      --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      --sans:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1100px 700px at 10% -10%, #ffe8cf 0%, transparent 60%),
        radial-gradient(900px 650px at 105% 0%, #d6f0ea 0%, transparent 55%),
        var(--bg);
    }
    header{
      position:sticky; top:0; z-index:20;
      backdrop-filter:blur(8px);
      background:rgba(251,246,238,.78);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    .brand{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .brand-left{display:flex;align-items:center;gap:12px}
    .mark{
      width:42px;height:42px;border-radius:14px;
      background:linear-gradient(145deg, rgba(198,90,46,.95), rgba(30,111,92,.9));
      box-shadow:0 10px 22px rgba(31,26,21,.12);
      position:relative;
    }
    .mark:after{
      content:""; position:absolute; inset:9px;
      border-radius:12px; background:rgba(251,246,238,.65);
      transform:rotate(10deg);
    }
    h1{font-size:16px;margin:0}
    .sub{margin:0;font-size:12px;color:var(--muted)}
    .cta-mini{display:flex;gap:10px;align-items:center;font-size:12px;color:var(--muted)}
    .pill{
      padding:8px 10px;border-radius:999px;background:var(--chip);
      border:1px solid var(--line);font-family:var(--mono)
    }
    main .wrap{
      padding:18px 16px 36px;
      display:grid;
      grid-template-columns: 460px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width:980px){ main .wrap{grid-template-columns:1fr} }
    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--radius2);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card-head{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      display:flex;align-items:baseline;justify-content:space-between;gap:12px;
    }
    .card-head h2{margin:0;font-size:14px}
    .card-head .hint{font-size:12px;color:var(--muted)}
    .card-body{padding:14px 16px 16px}
    .grid{display:grid;gap:12px}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    select,input[type="text"],input[type="number"],input[type="range"],input[type="search"],textarea{
      width:100%;
      padding:12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:#fff;
      color:var(--ink);
      outline:none;
    }
    textarea{min-height:44px;resize:vertical}
    input[type="range"]{height:42px;padding:10px}
    select:focus,input:focus,textarea:focus{box-shadow:var(--focus);border-color:rgba(198,90,46,.55)}
    .row2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px}
    @media (max-width:560px){ .row2,.row3{grid-template-columns:1fr} }
    .divider{height:1px;background:var(--line);margin:12px 0}
    .btn{
      appearance:none;
      border:1px solid var(--line);
      background:#fff;
      color:var(--ink);
      border-radius:999px;
      padding:10px 12px;
      font-weight:600;
      cursor:pointer;
      transition:transform .05s ease, box-shadow .2s ease, background .2s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{transform:translateY(-1px);box-shadow:0 10px 20px rgba(31,26,21,.10)}
    .btn:active{transform:translateY(0);box-shadow:none}
    .btn.primary{
      border-color:rgba(198,90,46,.4);
      background:linear-gradient(135deg, rgba(198,90,46,.95), rgba(198,90,46,.78));
      color:#fff;
    }
    .btn.ghost{background:transparent}
    .btn.danger{
      border-color:rgba(198,90,46,.25);
      background:rgba(198,90,46,.08);
      color:#6d2d17;
    }
    .btn.toggle-on{
      border-color:rgba(198,90,46,.35);
      background:rgba(198,90,46,.10);
    }
    .uploader{
      border:1px dashed rgba(31,26,21,.25);
      background:rgba(255,255,255,.6);
      border-radius:16px;
      padding:12px;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    .uploader .meta{display:flex;flex-direction:column;gap:3px;min-width:0}
    .uploader .meta b{font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .uploader .meta span{font-size:12px;color:var(--muted)}
    .chips{display:flex;flex-wrap:wrap;gap:8px}
    .chip{
      display:flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);background:#fff;
      cursor:pointer;font-size:12px;
    }
    .chip input{accent-color:var(--accent)}
    .swatch{width:12px;height:12px;border-radius:999px;border:1px solid rgba(31,26,21,.18)}
    details summary{
      cursor:pointer; user-select:none; list-style:none;
      font-size:12px; color:var(--muted);
      padding:10px 12px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.45);
      border-radius:16px;
    }
    details summary::-webkit-details-marker{display:none}
    details[open] summary{box-shadow:var(--focus);border-color:rgba(198,90,46,.35)}
    .note{
      background:rgba(30,111,92,.08);
      border:1px solid rgba(30,111,92,.18);
      padding:10px 12px;
      border-radius:16px;
      color:#164b3f;
      font-size:12px;
      line-height:1.35;
    }
    .warn{
      background:rgba(198,90,46,.08);
      border:1px solid rgba(198,90,46,.18);
      color:#6d2d17;
    }
    .small{font-size:12px;color:var(--muted)}
    .mono{font-family:var(--mono)}
    .sr{position:absolute;left:-9999px}
    /* Preview */
    .preview{display:grid;gap:14px}
    .stage{padding:16px}
    .stage-top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px}
    .stage-top .title{display:flex;flex-direction:column;gap:2px}
    .stage-top .title b{font-size:14px}
    .stage-top .title span{font-size:12px;color:var(--muted)}
    .canvas-shell{
      border-radius:26px;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.75), rgba(255,255,255,.25));
      padding:14px;
    }
    .canvas-inner{
      display:grid;place-items:center;
      background:rgba(31,26,21,.04);
      border-radius:20px;
      padding:18px;
      overflow:hidden;
      position:relative;
      touch-action:none;
    }
    canvas{
      width:min(520px, 92vw);
      height:auto;
      display:block;
      border-radius:18px;
      box-shadow:0 16px 28px rgba(31,26,21,.14);
      background:#fff;
    }
    .stage-actions{
      display:flex;flex-wrap:wrap;gap:10px;
      align-items:center;justify-content:space-between;
      margin-top:12px;
    }
    .stage-actions .left{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .status{
      margin-top:10px;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.6);
      font-size:12px;color:var(--muted);line-height:1.35;
    }
    .status b{color:var(--ink)}
    /* Sticky preview */
    .preview-sticky{
      position:sticky;
      top:92px; /* below header */
      align-self:start;
    }
    @media (max-width:980px){
      .preview-sticky{position:static; top:auto;}
    }
    /* Texture manager */
    .texture-list{display:grid;gap:10px;margin-top:10px}
    .tex-row{
      display:grid;
      grid-template-columns:1fr auto;
      gap:10px;
      align-items:center;
      padding:10px;
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(255,255,255,.55);
    }
    .tex-left{display:flex;gap:10px;align-items:center;min-width:0}
    .tex-thumb{
      width:44px;height:44px;border-radius:14px;
      border:1px solid var(--line);background:#fff;overflow:hidden;flex:0 0 auto;
    }
    .tex-thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .tex-meta{display:flex;flex-direction:column;gap:2px;min-width:0}
    .tex-meta b{font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .tex-meta span{font-size:12px;color:var(--muted)}
    .tex-actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
    /* Icon grid */
    .icon-grid{
      margin-top:10px;
      display:grid;
      grid-template-columns:repeat(6, 1fr);
      gap:8px;
    }
    @media (max-width:560px){ .icon-grid{grid-template-columns:repeat(4, 1fr)} }
    .icon-btn{
      border:1px solid var(--line);
      background:rgba(255,255,255,.7);
      border-radius:14px;
      padding:10px;
      display:grid;
      place-items:center;
      cursor:pointer;
      transition:transform .05s ease, box-shadow .2s ease;
      min-height:44px;
    }
    .icon-btn:hover{transform:translateY(-1px);box-shadow:0 10px 18px rgba(31,26,21,.10)}
    .icon-btn svg{width:22px;height:22px}
    .icon-meta{
      font-size:12px;color:var(--muted);
      margin-top:8px;
      display:flex;justify-content:space-between;gap:8px;
    }
    /* Layers */
    .layers{
      display:grid;
      gap:8px;
      margin-top:8px;
    }
    .layer{
      border:1px solid var(--line);
      background:rgba(255,255,255,.55);
      border-radius:16px;
      padding:10px;
      display:grid;
      gap:8px;
    }
    .layer-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .layer-top b{font-size:13px}
    .layer-top .tag{
      font-size:12px;
      color:var(--muted);
      font-family:var(--mono);
    }
    .layer-actions{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    /* Uploadcare hidden input */
    .uc-hidden{ position:absolute; left:-9999px; }
  </style>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&family=Playfair+Display:wght@400;600;700&family=Montserrat:wght@400;600;700&family=Poppins:wght@400;600;700&family=Raleway:wght@400;600;700&family=Oswald:wght@400;600&family=Bebas+Neue&family=Pacifico&family=Great+Vibes&family=Roboto+Slab:wght@400;600;700&family=Source+Serif+4:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
  <!-- Uploadcare Widget -->
  <script>
    UPLOADCARE_PUBLIC_KEY = "53eeccec14419f6dd5c8";
    UPLOADCARE_LOCALE = "en";
    UPLOADCARE_TABS = "file url camera";
  </script>
  <script src="https://ucarecdn.com/libs/widget/3.x/uploadcare.full.min.js" charset="utf-8"></script>
</head>
<body>
<header>
  <div class="wrap">
    <div class="brand">
      <div class="brand-left">
        <div class="mark" aria-hidden="true"></div>
        <div>
          <h1>Custom Coasters</h1>
          <p class="sub">Tap/click outside to deselect · Drag to move · Handles resize · Rotate handle rotates · Wheel/pinch zoom</p>
        </div>
      </div>
      <div class="cta-mini">
        <span class="pill">Sticky preview</span>
        <span class="pill">Multi icons</span>
        <span class="pill">Text boxes</span>
      </div>
    </div>
  </div>
</header>
<main>
  <div class="wrap">
    <!-- Controls -->
    <section class="card">
      <div class="card-head">
        <h2>Design</h2>
        <div class="hint">Add layers → edit in preview</div>
      </div>
      <div class="card-body">
        <div class="grid">
          <div class="row2">
            <div>
              <label for="shape">Shape</label>
              <select id="shape">
                <option value="round">Round</option>
                <option value="square">Square</option>
                <option value="hex">Hex</option>
              </select>
            </div>
            <div>
              <label for="size">Size</label>
              <select id="size">
                <option value="3.5">3.5"</option>
                <option value="4.0" selected>4.0"</option>
                <option value="4.5">4.5"</option>
              </select>
            </div>
          </div>
          <div>
            <label>Material</label>
            <div class="chips" id="materials"></div>
          </div>
          <details>
            <summary>Material texture photos (optional)</summary>
            <div class="small" style="margin-top:8px;">
              Upload your real wood/slate photos here (saved in your browser). These textures appear behind the engraving preview.
            </div>
            <div class="texture-list" id="textureList"></div>
            <div class="note" style="margin-top:10px;">Tip: square-ish photos (800×800+) look best.</div>
          </details>
          <div class="divider"></div>
          <input id="ucUploader" class="uc-hidden" type="hidden" role="uploadcare-uploader"
                 data-clearable="true" data-images-only="true" data-preview-step="true" data-image-shrink="2200x2200" />
          <div>
            <label>Artwork layer (optional)</label>
            <div class="uploader">
              <div class="meta">
                <b id="artName">No file uploaded yet</b>
                <span>Opens Uploadcare box</span>
              </div>
              <div>
                <button type="button" class="btn" id="artPick">Upload</button>
              </div>
            </div>
            <div class="row2" style="margin-top:10px;">
              <button type="button" class="btn ghost" id="fitArtwork">Fit</button>
              <button type="button" class="btn danger" id="clearArtwork">Clear</button>
            </div>
          </div>
          <div class="divider"></div>
          <div>
            <label>Icons (SVG-style, add multiple)</label>
            <div class="row2">
              <input id="iconSearch" type="search" placeholder="Search icons… (coffee, heart, leaf, star)" />
              <button type="button" class="btn" id="iconSearchBtn">Search</button>
            </div>
            <div class="icon-grid" id="iconGrid"></div>
            <div class="icon-meta">
              <span id="iconStatus">Search to load icons.</span>
              <span class="mono" id="iconPicked">—</span>
            </div>
            <div class="row2" style="margin-top:10px;">
              <button type="button" class="btn primary" id="addIcon">Add selected icon</button>
              <button type="button" class="btn danger" id="deleteSelected">Delete selected</button>
            </div>
            <div class="note" style="margin-top:10px;">
              Pick an icon, click <b>Add selected icon</b> (you can add many), then move/resize/rotate each one in the preview.
            </div>
          </div>
          <div class="divider"></div>
          <div>
            <label>Text boxes (add as many as you want)</label>
            <div class="row2">
              <button type="button" class="btn primary" id="addText">Add text box</button>
              <button type="button" class="btn ghost" id="duplicateSelected">Duplicate selected</button>
            </div>
            <div class="layers" id="layers"></div>
            <div class="note" style="margin-top:10px;">
              <b>Curve strength:</b> from box proportions (taller = stronger arc).<br>
              <b>Vertical stacking:</b> make box tall & narrow → text stacks like a ladder.
            </div>
          </div>
          <div class="divider"></div>
          <div class="note">
            Submit uploads a proof PNG for production. Customer never sees hosted URLs.
          </div>
        </div>
      </div>
    </section>
    <!-- Preview -->
    <section class="preview preview-sticky">
      <section class="card stage">
        <div class="stage-top">
          <div class="title">
            <b>Preview</b>
            <span>Laser-style engraving simulation (dark burn look)</span>
          </div>
          <div class="small mono" id="summary"></div>
        </div>
        <div class="canvas-shell">
          <div class="canvas-inner" id="canvasWrap">
            <canvas id="cv" width="900" height="900" aria-label="Coaster preview"></canvas>
          </div>
        </div>
        <div class="stage-actions">
          <div class="left">
            <button type="button" class="btn" id="downloadPng">Download proof PNG</button>
            <button type="button" class="btn" id="copyCode">Copy order code</button>
            <button type="button" class="btn primary" id="submitDesign">Submit (host proof)</button>
          </div>
          <div class="small">Tip: click background to deselect</div>
        </div>
        <div class="status" id="statusBox">
          <b>Status:</b> Ready.
        </div>
      </section>
    </section>
  </div>
</main>

<script>
// ──────────────────────────────────────────────────────────────────────────────
// DATA & CONSTANTS
// ──────────────────────────────────────────────────────────────────────────────
const MATERIALS = [
  { id:"birch", name:"Birch", tone:"#e7d2b3" },
  { id:"walnut", name:"Walnut", tone:"#6a4b34" },
  { id:"bamboo", name:"Bamboo", tone:"#d9c38f" },
  { id:"cork", name:"Cork", tone:"#c2a47a" },
  { id:"slate", name:"Slate", tone:"#4b4d52" }
];

const FONT_OPTIONS = [
  { name:"Classic Serif (Playfair)", css:`"Playfair Display", Georgia, serif` },
  { name:"Book Serif (Source Serif)", css:`"Source Serif 4", Georgia, serif` },
  { name:"Warm Serif (Libre Baskerville)", css:`"Libre Baskerville", Georgia, serif` },
  { name:"Slab (Roboto Slab)", css:`"Roboto Slab", Georgia, serif` },
  { name:"Modern Sans (Montserrat)", css:`Montserrat, system-ui, sans-serif` },
  { name:"Clean Sans (Poppins)", css:`Poppins, system-ui, sans-serif` },
  { name:"Elegant Sans (Raleway)", css:`Raleway, system-ui, sans-serif` },
  { name:"Bold Display (Oswald)", css:`Oswald, system-ui, sans-serif` },
  { name:"ALL CAPS (Bebas Neue)", css:`"Bebas Neue", system-ui, sans-serif` },
  { name:"Script (Pacifico)", css:`Pacifico, cursive` },
  { name:"Fancy Script (Great Vibes)", css:`"Great Vibes", cursive` },
  { name:"Mono (IBM Plex Mono)", css:`"IBM Plex Mono", ui-monospace, monospace` },
  { name:"System (Default)", css:`system-ui, -apple-system, Segoe UI, Roboto, sans-serif` },
];

const KEYS = { textures: "coaster_material_textures_v1" };

// DOM elements
const $ = id => document.getElementById(id);
const cv = $("cv");
const ctx = cv.getContext("2d");
const canvasWrap = $("canvasWrap");
const elShape = $("shape");
const elSize = $("size");
const summary = $("summary");
const ucInput = $("ucUploader");
const ucWidget = uploadcare.Widget(ucInput);
const artPick = $("artPick");
const artName = $("artName");
const fitArtworkBtn = $("fitArtwork");
const clearArtworkBtn = $("clearArtwork");
const iconSearch = $("iconSearch");
const iconSearchBtn = $("iconSearchBtn");
const iconGrid = $("iconGrid");
const iconStatus = $("iconStatus");
const iconPicked = $("iconPicked");
const addIconBtn = $("addIcon");
const addTextBtn = $("addText");
const layersEl = $("layers");
const deleteSelectedBtn = $("deleteSelected");
const duplicateSelectedBtn = $("duplicateSelected");
const downloadPng = $("downloadPng");
const copyCodeBtn = $("copyCode");
const submitDesign = $("submitDesign");
const statusBox = $("statusBox");

// ──────────────────────────────────────────────────────────────────────────────
// STATE
// ──────────────────────────────────────────────────────────────────────────────
const state = {
  material: MATERIALS[0].id,
  shape: "round",
  size: 4.0,
  artUrl: "",
  artPreviewUrl: "",
  artImage: null,
  artLayer: { id:"art", type:"art", name:"Artwork", x:0, y:0, w:1.4, h:1.4, rot:0 },
  iconCatalogSelected: { name:"", svg:"", img:null },
  layers: [],
  selectedId: null,           // ← changed default: start with nothing selected
  textureMap: loadTextureMap(),
  textureImgCache: {}
};

const pointerState = {
  active: new Map(),
  lastTapTime: 0,
  lastCentroid: null,
  lastDist: 0
};

const transformState = {
  action: null,
  start: null,
  handleIndex: -1
};

// ──────────────────────────────────────────────────────────────────────────────
// UTILITY HELPERS
// ──────────────────────────────────────────────────────────────────────────────
const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);

function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function clamp01(v) { return Math.max(0, Math.min(1, v)); }
function degToRad(d) { return d * Math.PI / 180; }

function escapeHtml(s) {
  return String(s||"").replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
}

function loadImage(url) {
  return new Promise((res, rej) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => res(img);
    img.onerror = () => rej(new Error("Image load failed"));
    img.src = url;
  });
}

function svgToImage(svgText) {
  return new Promise((res, rej) => {
    const blob = new Blob([svgText], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => { URL.revokeObjectURL(url); res(img); };
    img.onerror = () => { URL.revokeObjectURL(url); rej(new Error("SVG decode failed")); };
    img.src = url;
  });
}

function fileToDataURL(file) {
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = () => res(r.result);
    r.onerror = rej;
    r.readAsDataURL(file);
  });
}

function dataURLToBlob(dataURL) {
  const [head, body] = dataURL.split(",");
  const mime = (head.match(/data:(.*?);base64/)||[])[1] || "application/octet-stream";
  const bin = atob(body);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
  return new Blob([bytes], { type: mime });
}

// ──────────────────────────────────────────────────────────────────────────────
// TEXTURE STORAGE
// ──────────────────────────────────────────────────────────────────────────────
function loadTextureMap() {
  try { return JSON.parse(localStorage.getItem(KEYS.textures)) || {}; }
  catch { return {}; }
}

function saveTextureMap(map) {
  localStorage.setItem(KEYS.textures, JSON.stringify(map || {}));
}

// ──────────────────────────────────────────────────────────────────────────────
// UI BUILD
// ──────────────────────────────────────────────────────────────────────────────
function buildMaterials() {
  const wrap = $("materials");
  wrap.innerHTML = "";
  MATERIALS.forEach((m, i) => {
    const lab = document.createElement("label");
    lab.className = "chip";
    lab.innerHTML = `
      <input type="radio" name="mat" value="${m.id}" ${i===0?"checked":""} />
      <span class="swatch" style="background:${m.tone}"></span>
      <span>${m.name}</span>
    `;
    lab.querySelector("input").addEventListener("change", () => {
      state.material = m.id;
      render();
    });
    wrap.appendChild(lab);
  });
}
buildMaterials();

function renderTextureManager() {
  const list = $("textureList");
  list.innerHTML = "";
  MATERIALS.forEach(m => {
    const url = state.textureMap[m.id] || "";
    const row = document.createElement("div");
    row.className = "tex-row";
    row.innerHTML = `
      <div class="tex-left">
        <div class="tex-thumb">${url ? `<img src="${url}" alt="${m.name}">` : ""}</div>
        <div class="tex-meta">
          <b>${m.name}</b>
          <span>${url ? "Custom photo" : "Uses flat color"}</span>
        </div>
      </div>
      <div class="tex-actions">
        <input type="file" accept="image/*" class="sr" id="texFile_${m.id}">
        <button class="btn ghost" id="texUp_${m.id}">Upload</button>
        <button class="btn" id="texClr_${m.id}" ${url?"":"disabled"}>Clear</button>
      </div>
    `;
    list.appendChild(row);

    const fileIn = row.querySelector(`#texFile_${m.id}`);
    row.querySelector(`#texUp_${m.id}`).onclick = () => fileIn.click();
    fileIn.onchange = async e => {
      const f = e.target.files[0];
      if (!f) return;
      const url = await fileToDataURL(f);
      state.textureMap[m.id] = url;
      saveTextureMap(state.textureMap);
      state.textureImgCache[m.id] = null;
      renderTextureManager();
      render();
    };
    row.querySelector(`#texClr_${m.id}`).onclick = () => {
      delete state.textureMap[m.id];
      saveTextureMap(state.textureMap);
      state.textureImgCache[m.id] = null;
      renderTextureManager();
      render();
    };
  });
}

function fontSelectHTML(selected) {
  return FONT_OPTIONS.map(f => {
    const sel = f.css === selected ? "selected" : "";
    return `<option value="${escapeHtml(f.css)}" style="font-family:${escapeHtml(f.css)}" ${sel}>${escapeHtml(f.name)}</option>`;
  }).join("");
}

function renderLayersPanel() {
  layersEl.innerHTML = "";

  // Artwork
  const artRow = document.createElement("div");
  artRow.className = "layer";
  artRow.innerHTML = `
    <div class="layer-top">
      <div><b>Artwork</b> <span class="tag mono">${state.artImage ? "loaded" : "none"}</span></div>
      <div class="layer-actions">
        <button class="btn ghost selArt ${state.selectedId==="art"?"toggle-on":""}">Select</button>
        <button class="btn ghost fitArt">Fit</button>
      </div>
    </div>
    <div class="small">Drag/resize/rotate in preview.</div>
  `;
  artRow.querySelector(".selArt").onclick = () => { state.selectedId = "art"; render(); renderLayersPanel(); };
  artRow.querySelector(".fitArt").onclick = () => { fitArtworkToCoaster(); state.selectedId = "art"; render(); renderLayersPanel(); };
  layersEl.appendChild(artRow);

  // Other layers
  state.layers.forEach((l, i) => {
    const row = document.createElement("div");
    row.className = "layer";
    if (l.type === "icon") {
      row.innerHTML = `
        <div class="layer-top">
          <div><b>Icon ${i+1}</b> <span class="tag">${escapeHtml(l.name||"icon")}</span></div>
          <div class="layer-actions">
            <button class="btn ghost sel ${state.selectedId===l.id?"toggle-on":""}">Select</button>
            <button class="btn ghost fit">Fit</button>
          </div>
        </div>
        <div class="small">Drag/resize/rotate in preview.</div>
      `;
      row.querySelector(".sel").onclick = () => { state.selectedId = l.id; render(); renderLayersPanel(); };
      row.querySelector(".fit").onclick = () => { fitIconLayer(l); state.selectedId = l.id; render(); renderLayersPanel(); };
    } else if (l.type === "text") {
      row.innerHTML = `
        <div class="layer-top">
          <div><b>Text ${i+1}</b> <span class="tag">${l.arcMode.toUpperCase()}</span></div>
          <div class="layer-actions">
            <button class="btn ghost sel ${state.selectedId===l.id?"toggle-on":""}">Select</button>
            <button class="btn ghost fit">Fit</button>
          </div>
        </div>
        <div class="row2">
          <textarea class="txt" placeholder="Type here…">${escapeHtml(l.text||"")}</textarea>
          <div>
            <label style="margin-bottom:6px">Font</label>
            ${fontSelectHTML(l.font)}
          </div>
        </div>
        <div class="row3" style="gap:8px;">
          <button class="btn arcOff ${l.arcMode==="off"?"toggle-on":""}">Arc off</button>
          <button class="btn arcUp ${l.arcMode==="up"?"toggle-on":""}">Arc up</button>
          <button class="btn arcDown ${l.arcMode==="down"?"toggle-on":""}">Arc down</button>
        </div>
        <div class="small">Tall narrow box → vertical stack. Wide/tall → curved arc.</div>
      `;
      const ta = row.querySelector(".txt");
      ta.oninput = () => { l.text = ta.value; state.selectedId = l.id; render(); };
      const fs = row.querySelector(".fontSel");
      fs.onchange = () => { l.font = fs.value; fs.style.fontFamily = fs.value; state.selectedId = l.id; render(); };
      fs.style.fontFamily = fs.value;
      row.querySelector(".sel").onclick = () => { state.selectedId = l.id; render(); renderLayersPanel(); };
      row.querySelector(".fit").onclick = () => { fitTextLayer(l); state.selectedId = l.id; render(); renderLayersPanel(); };
      row.querySelector(".arcOff").onclick = () => { l.arcMode = "off"; state.selectedId = l.id; render(); renderLayersPanel(); };
      row.querySelector(".arcUp").onclick   = () => { l.arcMode = "up";   state.selectedId = l.id; render(); renderLayersPanel(); };
      row.querySelector(".arcDown").onclick = () => { l.arcMode = "down"; state.selectedId = l.id; render(); renderLayersPanel(); };
    }
    layersEl.appendChild(row);
  });
}

// ──────────────────────────────────────────────────────────────────────────────
// LAYER FIT HELPERS
// ──────────────────────────────────────────────────────────────────────────────
function fitArtworkToCoaster() {
  state.artLayer.x = 0; state.artLayer.y = 0;
  state.artLayer.w = 1.35; state.artLayer.h = 1.35;
  state.artLayer.rot = 0;
}

function fitIconLayer(layer) {
  layer.x = 0; layer.y = 0;
  layer.w = 0.55; layer.h = 0.55;
  layer.rot = 0;
}

function fitTextLayer(layer) {
  layer.x = 0; layer.y = 0.35;
  layer.w = 0.95; layer.h = 0.26;
  layer.rot = 0;
}

// ──────────────────────────────────────────────────────────────────────────────
// CANVAS GEOMETRY & COORDINATES
// ──────────────────────────────────────────────────────────────────────────────
function getCanvasClientRect() { return cv.getBoundingClientRect(); }

function canvasToLocal(px, py) {
  const r = getCanvasClientRect();
  return {
    x: (px - r.left) * (cv.width / r.width),
    y: (py - r.top) * (cv.height / r.height)
  };
}

function coasterGeom() {
  const pad = 85;
  const cx = cv.width / 2;
  const cy = cv.height / 2 + 10;
  const rr = (cv.width - pad * 2) * 0.43;
  return { cx, cy, r: rr };
}

function getSafeBox(cx, cy, r, shape) {
  if (shape === "round") return { x: cx - r*0.78, y: cy - r*0.78, w: r*1.56, h: r*1.56 };
  if (shape === "square") {
    const s = r * 1.58;
    return { x: cx - s*0.42, y: cy - s*0.42, w: s*0.84, h: s*0.84 };
  }
  return { x: cx - r*0.78, y: cy - r*0.70, w: r*1.56, h: r*1.40 };
}

function normToLocalBox(nx, ny, box) {
  return {
    x: box.x + box.w/2 + nx * (box.w/2),
    y: box.y + box.h/2 + ny * (box.h/2)
  };
}

function normSizeToLocal(nw, nh, box) {
  return {
    w: nw * (box.w / 2),
    h: nh * (box.h / 2)
  };
}

function getLayerRectInCanvas(layer, box) {
  const c = normToLocalBox(layer.x, layer.y, box);
  const sz = normSizeToLocal(layer.w, layer.h, box);
  return { cx: c.x, cy: c.y, w: Math.max(10, sz.w), h: Math.max(10, sz.h), rot: layer.rot || 0 };
}

// ──────────────────────────────────────────────────────────────────────────────
// SELECTION & HIT TESTING
// ──────────────────────────────────────────────────────────────────────────────
function rotRectHandlePoints(cx, cy, w, h, rot) {
  const pts = [
    {x:-w/2,y:-h/2}, {x:0,y:-h/2}, {x:w/2,y:-h/2},
    {x:w/2,y:0},
    {x:w/2,y:h/2}, {x:0,y:h/2}, {x:-w/2,y:h/2},
    {x:-w/2,y:0}
  ];
  return pts.map(p => {
    const xr = p.x * Math.cos(rot) - p.y * Math.sin(rot);
    const yr = p.x * Math.sin(rot) + p.y * Math.cos(rot);
    return { x: cx + xr, y: cy + yr };
  });
}

function rotateHandlePoint(x, y, cx, cy, offset) {
  const vx = x - cx, vy = y - cy;
  const len = Math.max(1, Math.hypot(vx, vy));
  return { x: x + (vx/len)*offset, y: y + (vy/len)*offset };
}

function hitTestHandle(px, py, hx, hy, r=14) {
  return Math.hypot(px - hx, py - hy) <= r;
}

function pointToRotatedLocal(px, py, rect) {
  const dx = px - rect.cx;
  const dy = py - rect.cy;
  const c = Math.cos(-rect.rot), s = Math.sin(-rect.rot);
  return { x: dx*c - dy*s, y: dx*s + dy*c };
}

function pickLayerAt(loc, box) {
  const candidates = [...state.layers].reverse();
  if (state.artImage) candidates.push(state.artLayer);

  for (const layer of candidates) {
    if (layer.type === "art" && !state.artImage) continue;
    if (layer.type === "icon" && !layer.img) continue;
    const rect = getLayerRectInCanvas(layer, box);
    const p = pointToRotatedLocal(loc.x, loc.y, rect);
    if (Math.abs(p.x) <= rect.w/2 && Math.abs(p.y) <= rect.h/2) {
      return layer.id;
    }
  }
  return null;
}

function getSelectedLayer() {
  if (state.selectedId === "art") return state.artLayer;
  return state.layers.find(l => l.id === state.selectedId) || null;
}

function hitTestSelection(loc, box) {
  const layer = getSelectedLayer();
  if (!layer) return { action: null };
  const rect = getLayerRectInCanvas(layer, box);
  const handles = rotRectHandlePoints(rect.cx, rect.cy, rect.w, rect.h, rect.rot);

  // Rotate handle
  const topMid = handles[1];
  const rotH = rotateHandlePoint(topMid.x, topMid.y, rect.cx, rect.cy, 26);
  if (hitTestHandle(loc.x, loc.y, rotH.x, rotH.y, 16)) {
    return { action: "rotate", rect, handleIndex: -1 };
  }

  // Resize handles
  for (let i = 0; i < handles.length; i++) {
    if (hitTestHandle(loc.x, loc.y, handles[i].x, handles[i].y, 14)) {
      return { action: "scale", rect, handleIndex: i };
    }
  }

  // Move (inside)
  const p = pointToRotatedLocal(loc.x, loc.y, rect);
  if (Math.abs(p.x) <= rect.w/2 && Math.abs(p.y) <= rect.h/2) {
    return { action: "move", rect, handleIndex: -1 };
  }

  return { action: null };
}

// ──────────────────────────────────────────────────────────────────────────────
// POINTER EVENTS
// ──────────────────────────────────────────────────────────────────────────────
canvasWrap.addEventListener("pointerdown", e => {
  cv.setPointerCapture(e.pointerId);
  const now = performance.now();
  const isDouble = (now - pointerState.lastTapTime) < 320;
  pointerState.lastTapTime = now;

  const loc = canvasToLocal(e.clientX, e.clientY);
  const { cx, cy, r } = coasterGeom();
  const box = getSafeBox(cx, cy, r, state.shape);

  const clickedId = pickLayerAt(loc, box);

  if (clickedId) {
    state.selectedId = clickedId;
  } else {
    state.selectedId = null;   // ← deselect on background click
  }

  if (isDouble) {
    // optional: cycle only if something is already selected
    if (state.selectedId) cycleSelection();
  }

  const ht = hitTestSelection(loc, box);
  if (ht.action) {
    const layer = getSelectedLayer();
    transformState.action = ht.action;
    transformState.handleIndex = ht.handleIndex;
    transformState.start = {
      x: loc.x, y: loc.y,
      layer: { x: layer.x, y: layer.y, w: layer.w, h: layer.h, rot: layer.rot || 0 },
      rect: ht.rect
    };
  } else {
    transformState.action = null;
    transformState.start = null;
    transformState.handleIndex = -1;
  }

  pointerState.active.set(e.pointerId, {x: e.clientX, y: e.clientY});
  if (pointerState.active.size === 2) {
    const pts = [...pointerState.active.values()];
    pointerState.lastCentroid = {x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2};
    pointerState.lastDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
  }

  render();
  renderLayersPanel();
});

canvasWrap.addEventListener("pointermove", e => {
  if (!pointerState.active.has(e.pointerId)) return;
  pointerState.active.set(e.pointerId, {x: e.clientX, y: e.clientY});

  const loc = canvasToLocal(e.clientX, e.clientY);
  const { cx, cy, r } = coasterGeom();
  const box = getSafeBox(cx, cy, r, state.shape);
  const layer = getSelectedLayer();
  if (!layer) return;

  // Single finger / mouse drag
  if (transformState.action && transformState.start && pointerState.active.size === 1) {
    if (transformState.action === "move") {
      const dx = loc.x - transformState.start.x;
      const dy = loc.y - transformState.start.y;
      layer.x = clamp(transformState.start.layer.x + dx/(box.w/2), -1.3, 1.3);
      layer.y = clamp(transformState.start.layer.y + dy/(box.h/2), -1.3, 1.3);
      render();
      return;
    }
    if (transformState.action === "rotate") {
      const c = normToLocalBox(transformState.start.layer.x, transformState.start.layer.y, box);
      const a0 = Math.atan2(transformState.start.y - c.y, transformState.start.x - c.x);
      const a1 = Math.atan2(loc.y - c.y, loc.x - c.x);
      layer.rot = transformState.start.layer.rot + (a1 - a0);
      render();
      return;
    }
    if (transformState.action === "scale") {
      const rect0 = transformState.start.rect;
      const p0 = pointToRotatedLocal(transformState.start.x, transformState.start.y, rect0);
      const p1 = pointToRotatedLocal(loc.x, loc.y, rect0);
      let w = transformState.start.layer.w;
      let h = transformState.start.layer.h;
      const dx = (p1.x - p0.x) / (box.w / 2);
      const dy = (p1.y - p0.y) / (box.h / 2);
      const hi = transformState.handleIndex;

      if (hi===0) { w -= dx; h -= dy; }
      if (hi===1) { h -= dy; }
      if (hi===2) { w += dx; h -= dy; }
      if (hi===3) { w += dx; }
      if (hi===4) { w += dx; h += dy; }
      if (hi===5) { h += dy; }
      if (hi===6) { w -= dx; h += dy; }
      if (hi===7) { w -= dx; }

      const min = layer.type === "text" ? 0.14 : 0.10;
      const max = layer.id === "art" ? 2.2 : 1.8;
      layer.w = clamp(w, min, max);
      layer.h = clamp(h, min, max);
      render();
      return;
    }
  }

  // Pinch zoom + pan
  if (pointerState.active.size === 2) {
    const pts = [...pointerState.active.values()];
    const cNow = {x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2};
    const dNow = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);

    if (pointerState.lastCentroid) {
      const dx = cNow.x - pointerState.lastCentroid.x;
      const dy = cNow.y - pointerState.lastCentroid.y;
      const rect = getCanvasClientRect();
      const dxC = dx * (cv.width / rect.width);
      const dyC = dy * (cv.height / rect.height);
      layer.x = clamp(layer.x + dxC/(box.w/2), -1.3, 1.3);
      layer.y = clamp(layer.y + dyC/(box.h/2), -1.3, 1.3);
    }

    if (pointerState.lastDist > 0) {
      const ratio = dNow / pointerState.lastDist;
      layer.w = clamp(layer.w * ratio, 0.08, layer.id==="art"?2.2:1.8);
      layer.h = clamp(layer.h * ratio, 0.08, layer.id==="art"?2.2:1.8);
    }

    pointerState.lastCentroid = cNow;
    pointerState.lastDist = dNow;
    render();
  }
});

canvasWrap.addEventListener("pointerup", e => {
  pointerState.active.delete(e.pointerId);
  if (pointerState.active.size < 2) {
    pointerState.lastCentroid = null;
    pointerState.lastDist = 0;
  }
  if (pointerState.active.size === 0) {
    transformState.action = null;
    transformState.start = null;
    transformState.handleIndex = -1;
  }
});

canvasWrap.addEventListener("wheel", e => {
  e.preventDefault();
  const layer = getSelectedLayer();
  if (!layer) return;
  const factor = Math.sign(e.deltaY) > 0 ? 0.94 : 1.06;
  layer.w = clamp(layer.w * factor, 0.08, layer.id==="art"?2.2:1.8);
  layer.h = clamp(layer.h * factor, 0.08, layer.id==="art"?2.2:1.8);
  render();
}, { passive: false });

function cycleSelection() {
  const ids = [...state.layers].reverse().map(l => l.id);
  if (state.artImage) ids.push("art");
  if (ids.length === 0) return;
  let i = ids.indexOf(state.selectedId);
  if (i === -1) i = -1;
  state.selectedId = ids[(i + 1) % ids.length];
}

// ──────────────────────────────────────────────────────────────────────────────
// RENDERING
// ──────────────────────────────────────────────────────────────────────────────
function render() {
  const mat = MATERIALS.find(m => m.id === state.material) || MATERIALS[0];
  summary.textContent = `${mat.name} · ${state.shape} · ${state.size.toFixed(1)}" · ${state.selectedId ? "sel: " + state.selectedId : "no selection"}`;

  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.fillStyle = "#f7efe4";
  ctx.fillRect(0,0,cv.width,cv.height);

  const { cx, cy, r } = coasterGeom();
  drawMaterialBase(cx, cy, r, mat);

  const engr = document.createElement("canvas");
  engr.width = cv.width;
  engr.height = cv.height;
  const ectx = engr.getContext("2d");
  ectx.save();
  clipShape(ectx, cx, cy, r, state.shape);
  const box = getSafeBox(cx, cy, r, state.shape);

  // Artwork first (bottom)
  if (state.artImage) {
    drawImageLayer(ectx, state.artImage, state.artLayer, box);
  }

  // Then icons & text in order
  state.layers.forEach(layer => {
    if (layer.type === "icon" && layer.img) {
      drawImageLayer(ectx, layer.img, layer, box);
    } else if (layer.type === "text") {
      drawTextBox(ectx, layer, box);
    }
  });

  ectx.restore();

  const mask = toEngraveMask(engr);
  applyEngraving(mask, cx, cy, r, state.shape);
  drawEdge(cx, cy, r, state.shape);

  // Selection box only if something is selected
  if (state.selectedId) {
    drawSelectionBox(box);
  }

  // Signature
  ctx.save();
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "#1f1a15";
  ctx.font = `14px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign = "center";
  ctx.fillText("preview", cx, cv.height - 28);
  ctx.restore();
}

function drawImageLayer(ectx, img, layer, box) {
  const rect = getLayerRectInCanvas(layer, box);
  ectx.save();
  ectx.translate(rect.cx, rect.cy);
  ectx.rotate(rect.rot);
  const fit = cover(img.width, img.height, rect.w, rect.h);
  ectx.drawImage(img, -fit.w/2, -fit.h/2, fit.w, fit.h);
  ectx.restore();
}

function quadraticBezierY(t, p0, p1, p2) {
  return (1-t)**2 * p0 + 2*(1-t)*t * p1 + t**2 * p2;
}

function drawTextBox(ectx, layer, box) {
  const rect = getLayerRectInCanvas(layer, box);
  const text = (layer.text || "").trim();
  if (!text) return;

  const aspect = rect.w / rect.h;
  const isVertical = aspect < 0.45; // tune this value

  ectx.save();
  ectx.translate(rect.cx, rect.cy);
  ectx.rotate(rect.rot);
  ectx.fillStyle = "#000";
  ectx.textAlign = "center";
  ectx.textBaseline = "middle";

  if (isVertical) {
    // Vertical ladder stacking
    const lines = text.split("\n");
    let fontSize = Math.min(rect.w * 0.9, rect.h * 0.22 / lines.length);
    fontSize = Math.max(10, Math.floor(fontSize));
    ectx.font = `${fontSize}px ${layer.font}`;
    const lineH = fontSize * 1.15;
    let y = - (lines.length - 1) * lineH / 2;

    lines.forEach(line => {
      const trimmed = line.trim();
      if (trimmed) ectx.fillText(trimmed, 0, y);
      y += lineH;
    });
  } else {
    // Horizontal + curved
    let fontSize = Math.max(10, Math.floor(rect.h * 0.62));
    ectx.font = `${fontSize}px ${layer.font}`;
    let tw = ectx.measureText(text).width;
    const maxW = rect.w - 24;
    while (fontSize > 10 && tw > maxW) {
      fontSize -= 2;
      ectx.font = `${fontSize}px ${layer.font}`;
      tw = ectx.measureText(text).width;
    }

    if (layer.arcMode === "off") {
      ectx.fillText(text, 0, 0);
    } else {
      // Quadratic curve following box edge
      const strength = clamp01((rect.h / rect.w - 0.35) / 1.1);
      const dir = layer.arcMode === "up" ? 1 : -1;
      const curveH = rect.h * 0.42 * strength * dir;
      const ctrlY = curveH * 0.65;

      const chars = [...text];
      let x = -tw / 2;

      chars.forEach(ch => {
        const mw = ectx.measureText(ch).width;
        const t = (x + mw/2 + tw/2) / tw; // 0..1 across text
        const yOffset = quadraticBezierY(t, 0, ctrlY, curveH);

        ectx.save();
        ectx.translate(x + mw/2, yOffset);
        // optional: slight rotation following tangent
        const t2 = t + 0.01;
        const dy = quadraticBezierY(t2, 0, ctrlY, curveH) - yOffset;
        const dx = mw * 0.01;
        ectx.rotate(Math.atan2(dy, dx));
        ectx.fillText(ch, 0, 0);
        ectx.restore();

        x += mw * 1.02;
      });
    }
  }

  ectx.restore();
}

function cover(w, h, bw, bh) {
  const s = Math.max(bw / w, bh / h);
  return { w: w * s, h: h * s };
}

// ──────────────────────────────────────────────────────────────────────────────
// LASER / MATERIAL RENDER HELPERS (unchanged)
// ──────────────────────────────────────────────────────────────────────────────
function drawMaterialBase(cx, cy, r, mat) {
  ctx.save();
  clipShape(ctx, cx, cy, r, state.shape);
  const tex = state.textureMap[mat.id];
  if (tex) {
    let img = state.textureImgCache[mat.id];
    if (!img) {
      img = new Image();
      img.onload = () => { state.textureImgCache[mat.id] = img; render(); };
      img.src = tex;
      ctx.fillStyle = mat.tone;
      ctx.fillRect(0,0,cv.width,cv.height);
    } else {
      drawCover(ctx, img, 0, 0, cv.width, cv.height);
    }
  } else {
    ctx.fillStyle = mat.tone;
    ctx.fillRect(0,0,cv.width,cv.height);
  }
  const noise = makeNoisePattern(240,240,0.12);
  ctx.globalAlpha = 0.28;
  ctx.drawImage(noise,0,0,cv.width,cv.height);
  const grad = ctx.createRadialGradient(cx,cy,r*0.2,cx,cy,r*1.25);
  grad.addColorStop(0,"rgba(255,255,255,0.10)");
  grad.addColorStop(1,"rgba(0,0,0,0.14)");
  ctx.globalAlpha = 1;
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,cv.width,cv.height);
  ctx.restore();
}

function applyEngraving(mask, cx, cy, r, shape) {
  ctx.save();
  clipShape(ctx, cx, cy, r, shape);
  const dark = document.createElement("canvas");
  dark.width = cv.width; dark.height = cv.height;
  const dctx = dark.getContext("2d");
  dctx.fillStyle = "#2b1b12";
  dctx.fillRect(0,0,cv.width,cv.height);
  dctx.globalCompositeOperation = "destination-in";
  dctx.drawImage(mask,0,0);
  ctx.globalAlpha = 0.92;
  ctx.drawImage(dark,0,0);
  ctx.globalAlpha = 0.16;
  ctx.globalCompositeOperation = "multiply";
  const n = makeNoisePattern(420,420,0.26);
  ctx.drawImage(n,0,0,cv.width,cv.height);
  ctx.restore();
  ctx.globalCompositeOperation = "source-over";
  ctx.globalAlpha = 1;
}

function drawEdge(cx, cy, r, shape) {
  ctx.save();
  ctx.lineWidth = 10;
  ctx.strokeStyle = "rgba(31,26,21,.22)";
  ctx.shadowColor = "rgba(31,26,21,.20)";
  ctx.shadowBlur = 18;
  ctx.shadowOffsetY = 10;
  drawShapePath(ctx, cx, cy, r, shape);
  ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.lineWidth = 6;
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  drawShapePath(ctx, cx, cy, r*0.97, shape);
  ctx.stroke();
  ctx.restore();
}

function clipShape(c, cx, cy, r, shape) {
  c.beginPath();
  if (shape === "round") c.arc(cx, cy, r, 0, Math.PI*2);
  else if (shape === "square") {
    const s = r*1.58;
    roundRectPath(c, cx - s/2, cy - s/2, s, s, r*0.16);
  } else {
    polygonPath(c, cx, cy, r*1.05, 6, -Math.PI/2);
  }
  c.closePath();
  c.clip();
}

function drawShapePath(c, cx, cy, r, shape) {
  c.beginPath();
  if (shape === "round") c.arc(cx, cy, r, 0, Math.PI*2);
  else if (shape === "square") {
    const s = r*1.58;
    roundRectPath(c, cx - s/2, cy - s/2, s, s, r*0.16);
  } else {
    polygonPath(c, cx, cy, r*1.05, 6, -Math.PI/2);
  }
  c.closePath();
}

function roundRectPath(c, x, y, w, h, r) {
  r = Math.min(r, w/2, h/2);
  c.moveTo(x+r, y);
  c.arcTo(x+w, y,   x+w, y+h, r);
  c.arcTo(x+w, y+h, x,   y+h, r);
  c.arcTo(x,   y+h, x,   y,   r);
  c.arcTo(x,   y,   x+w, y,   r);
}

function polygonPath(c, cx, cy, radius, sides, rot) {
  for (let i = 0; i < sides; i++) {
    const a = rot + i * (Math.PI*2 / sides);
    const x = cx + Math.cos(a) * radius;
    const y = cy + Math.sin(a) * radius;
    i === 0 ? c.moveTo(x,y) : c.lineTo(x,y);
  }
}

function toEngraveMask(src) {
  const w = src.width, h = src.height;
  const out = document.createElement("canvas");
  out.width = w; out.height = h;
  const octx = out.getContext("2d");
  const data = src.getContext("2d").getImageData(0,0,w,h).data;
  const d = new Uint8ClampedArray(data);

  for (let i = 0; i < d.length; i += 4) {
    const lum = (0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]) / 255;
    let alpha = 0;
    if (lum < 0.92) {
      if (lum <= 0.70) alpha = clamp01((1 - lum - 0.05) / 0.95);
      else alpha = clamp01((0.92 - lum) / (0.92 - 0.70) * 0.55);
    }
    alpha = Math.pow(alpha, 0.85);
    d[i] = d[i+1] = d[i+2] = 0;
    d[i+3] = Math.round(alpha * 255);
  }
  octx.putImageData(new ImageData(d, w, h), 0, 0);
  octx.filter = "blur(0.7px)";
  octx.drawImage(out, 0, 0);
  return out;
}

function makeNoisePattern(w, h, strength) {
  const c = document.createElement("canvas");
  c.width = w; c.height = h;
  const x = c.getContext("2d");
  const img = x.createImageData(w, h);
  const d = img.data;
  for (let i = 0; i < d.length; i += 4) {
    const v = 210 + Math.random() * 45;
    d[i] = d[i+1] = d[i+2] = v;
    d[i+3] = Math.round(255 * strength * Math.random());
  }
  x.putImageData(img, 0, 0);
  return c;
}

function drawCover(c, img, x, y, w, h) {
  const ir = img.width / img.height;
  const cr = w / h;
  let dw = w, dh = h, dx = x, dy = y;
  if (ir > cr) {
    dh = h; dw = h * ir; dx = x - (dw - w)/2;
  } else {
    dw = w; dh = w / ir; dy = y - (dh - h)/2;
  }
  c.drawImage(img, dx, dy, dw, dh);
}

function drawSelectionBox(box) {
  const layer = getSelectedLayer();
  if (!layer) return;
  if (layer.id === "art" && !state.artImage) return;

  const rect = getLayerRectInCanvas(layer, box);
  const rot = rect.rot;

  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(31,26,21,.55)";
  ctx.setLineDash([6,4]);
  ctx.save();
  ctx.translate(rect.cx, rect.cy);
  ctx.rotate(rot);
  ctx.strokeRect(-rect.w/2, -rect.h/2, rect.w, rect.h);
  ctx.restore();
  ctx.setLineDash([]);

  const pts = rotRectHandlePoints(rect.cx, rect.cy, rect.w, rect.h, rot);
  pts.forEach(p => {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.strokeStyle = "rgba(31,26,21,.55)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(p.x-7, p.y-7, 14, 14);
    ctx.fill(); ctx.stroke();
    ctx.restore();
  });

  const top = pts[1];
  const rh = rotateHandlePoint(top.x, top.y, rect.cx, rect.cy, 26);
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,.95)";
  ctx.strokeStyle = "rgba(31,26,21,.55)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(rh.x, rh.y, 8, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();
  ctx.restore();

  ctx.strokeStyle = "rgba(31,26,21,.35)";
  ctx.beginPath();
  ctx.moveTo(top.x, top.y);
  ctx.lineTo(rh.x, rh.y);
  ctx.stroke();
  ctx.restore();
}

// ──────────────────────────────────────────────────────────────────────────────
// EVENT LISTENERS & INITIALIZATION
// ──────────────────────────────────────────────────────────────────────────────
elShape.onchange = () => { state.shape = elShape.value; render(); };
elSize.onchange = () => { state.size = parseFloat(elSize.value); render(); };

artPick.onclick = async e => {
  e.preventDefault();
  if (!UPLOADCARE_PUBLIC_KEY?.trim()) return setStatus("Missing Uploadcare key", true);
  try { await ucWidget.openDialog().done(()=>{}); } catch {}
};

ucWidget.onUploadComplete(async info => {
  try {
    setStatus("Loading artwork…", false);
    state.artUrl = info.cdnUrl;
    state.artPreviewUrl = info.cdnUrl + "-/preview/1800x1800/";
    artName.textContent = info.name || "Artwork";
    state.artImage = await loadImage(state.artPreviewUrl);
    state.selectedId = "art";
    fitArtworkToCoaster();
    setStatus("Artwork loaded.", false);
    render(); renderLayersPanel();
  } catch (err) {
    setStatus("Artwork load failed.", true);
  }
});

fitArtworkBtn.onclick = () => {
  fitArtworkToCoaster();
  state.selectedId = "art";
  render(); renderLayersPanel();
};

clearArtworkBtn.onclick = () => {
  state.artUrl = state.artPreviewUrl = "";
  state.artImage = null;
  artName.textContent = "No file uploaded yet";
  if (state.selectedId === "art") state.selectedId = state.layers[0]?.id || null;
  render(); renderLayersPanel();
};

iconSearchBtn.onclick = iconSearchRun;
iconSearch.onkeydown = e => { if (e.key === "Enter") { e.preventDefault(); iconSearchRun(); } };

async function iconSearchRun() {
  const q = iconSearch.value.trim();
  if (!q) {
    iconStatus.textContent = "Enter search term (coffee, heart…)";
    iconGrid.innerHTML = "";
    return;
  }
  iconStatus.textContent = "Searching…";
  iconGrid.innerHTML = "";
  try {
    const res = await fetch(`https://api.iconify.design/search?query=${encodeURIComponent(q)}&prefix=tabler&limit=48`);
    const data = await res.json();
    const icons = data?.icons || [];
    if (!icons.length) {
      iconStatus.textContent = "No icons found";
      return;
    }
    iconStatus.textContent = `Found ${Math.min(icons.length,48)} icons`;
    const frag = document.createDocumentFragment();
    icons.slice(0,48).forEach(full => {
      const name = full.split(":").pop();
      const btn = document.createElement("button");
      btn.className = "icon-btn";
      btn.title = `tabler:${name}`;
      btn.innerHTML = `<svg viewBox="0 0 24 24"><path d=""/></svg>`;
      fetch(`https://api.iconify.design/tabler/${name}.svg?color=%231f1a15`)
        .then(r => r.text())
        .then(svg => { if (svg) btn.innerHTML = svg; });
      btn.onclick = () => pickIcon(name);
      frag.appendChild(btn);
    });
    iconGrid.appendChild(frag);
  } catch {
    iconStatus.textContent = "Search failed";
  }
}

async function pickIcon(name) {
  try {
    setStatus("Loading icon…", false);
    const res = await fetch(`https://api.iconify.design/tabler/${name}.svg?color=%23000000`);
    const svg = await res.text();
    const img = await svgToImage(svg);
    state.iconCatalogSelected = { name:`tabler:${name}`, svg, img };
    iconPicked.textContent = state.iconCatalogSelected.name;
    setStatus("Icon ready — click Add", false);
  } catch {
    setStatus("Icon load failed", true);
  }
}

addIconBtn.onclick = () => {
  if (!state.iconCatalogSelected.img) return setStatus("Select an icon first", true);
  const id = uid();
  const layer = {
    id, type: "icon", name: state.iconCatalogSelected.name,
    img: state.iconCatalogSelected.img,
    x: 0, y: 0, w: 0.60, h: 0.60, rot: 0
  };
  fitIconLayer(layer);
  state.layers.push(layer);
  state.selectedId = id;
  setStatus("Icon added", false);
  render(); renderLayersPanel();
};

addTextBtn.onclick = () => {
  const id = uid();
  const layer = {
    id, type: "text", text: "YOUR TEXT",
    font: FONT_OPTIONS[4].css,
    x: 0, y: 0.35, w: 0.90, h: 0.26, rot: 0,
    arcMode: "up"
  };
  fitTextLayer(layer);
  state.layers.push(layer);
  state.selectedId = id;
  setStatus("Text box added — resize to curve or stack", false);
  render(); renderLayersPanel();
};

duplicateSelectedBtn.onclick = () => {
  const sel = getSelectedLayer();
  if (!sel || sel.id === "art") return setStatus("Select icon/text to duplicate", true);
  const copy = structuredClone(sel);
  copy.id = uid();
  copy.x += 0.06; copy.y += 0.06;
  state.layers.push(copy);
  state.selectedId = copy.id;
  render(); renderLayersPanel();
};

deleteSelectedBtn.onclick = () => {
  if (state.selectedId === "art") return setStatus("Use Clear for artwork", true);
  const idx = state.layers.findIndex(l => l.id === state.selectedId);
  if (idx === -1) return setStatus("Nothing selected", true);
  state.layers.splice(idx, 1);
  state.selectedId = state.layers[idx-1]?.id || state.layers[0]?.id || null;
  render(); renderLayersPanel();
};

downloadPng.onclick = () => {
  const a = document.createElement("a");
  a.download = "coaster-proof.png";
  a.href = cv.toDataURL("image/png");
  a.click();
};

copyCodeBtn.onclick = () => copyText(buildOrderCode(), copyCodeBtn, "Copied!");

submitDesign.onclick = async () => {
  if (!UPLOADCARE_PUBLIC_KEY?.trim()) return setStatus("Missing Uploadcare key", true);
  try {
    setStatus("Uploading proof…", false);
    const blob = dataURLToBlob(cv.toDataURL("image/png"));
    await uploadToUploadcare(blob, "coaster-proof.png");
    setStatus("Proof submitted (use order code)", false);
  } catch (err) {
    setStatus("Upload failed", true);
  }
};

async function uploadToUploadcare(blob, name) {
  const fd = new FormData();
  fd.append("UPLOADCARE_PUB_KEY", UPLOADCARE_PUBLIC_KEY);
  fd.append("UPLOADCARE_STORE", "1");
  fd.append("file", blob, name);
  const res = await fetch("https://upload.uploadcare.com/base/", { method: "POST", body: fd });
  if (!res.ok) throw new Error(`Upload failed ${res.status}`);
  const data = await res.json();
  if (!data.file) throw new Error("No file UUID");
  return `https://ucarecdn.com/${data.file}/`;
}

function buildOrderCode() {
  const s = v => String(v||"").replace(/\|/g,"/").trim().slice(0,120);
  const layersCode = state.layers.map((l,i) => {
    if (l.type === "icon") {
      return `I${i}:${s(l.name)}@${l.x.toFixed(3)},${l.y.toFixed(3)},${l.w.toFixed(3)},${l.h.toFixed(3)},${(l.rot||0).toFixed(3)}`;
    }
    return `T${i}:${shortenFont(l.font)}:${s(l.text)}:${l.arcMode}@${l.x.toFixed(3)},${l.y.toFixed(3)},${l.w.toFixed(3)},${l.h.toFixed(3)},${(l.rot||0).toFixed(3)}`;
  }).join("|") || "layers:none";

  return [
    "COASTER5",
    `mat:${state.material}`,
    `shape:${state.shape}`,
    `size:${state.size.toFixed(1)}`,
    `art:${state.artImage?1:0}@${state.artLayer.x.toFixed(3)},${state.artLayer.y.toFixed(3)},${state.artLayer.w.toFixed(3)},${state.artLayer.h.toFixed(3)},${(state.artLayer.rot||0).toFixed(3)}`,
    layersCode
  ].join("|");
}

function shortenFont(f) {
  return (f||"").split(",")[0].replace(/['"]/g,"").trim().slice(0,18);
}

function setStatus(msg, err = false) {
  statusBox.innerHTML = `<b>Status:</b> ${escapeHtml(msg)}`;
  statusBox.style.borderColor = err ? "rgba(198,90,46,.35)" : "rgba(231,220,207,1)";
  statusBox.style.background = err ? "rgba(198,90,46,.08)" : "rgba(255,255,255,.6)";
  statusBox.style.color = err ? "#6d2d17" : "var(--muted)";
}

function copyText(text, btn, label) {
  text = (text||"").trim();
  if (!text) return setStatus("Nothing to copy", true);
  navigator.clipboard.writeText(text)
    .then(() => {
      const old = btn.textContent;
      btn.textContent = label;
      setTimeout(() => btn.textContent = old, 1200);
    })
    .catch(() => alert(text));
}

// ──────────────────────────────────────────────────────────────────────────────
// START
// ──────────────────────────────────────────────────────────────────────────────
renderTextureManager();
renderLayersPanel();
render();
setStatus("Ready. Click background to deselect.", false);

// Optional: demo search
iconSearch.value = "coffee";
iconSearchRun();
</script>
</body>
</html>
