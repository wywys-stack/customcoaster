<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nice Coasters — Designer</title>

  <style>
    :root{
      --bg:#fbf6ee;
      --ink:#1f1a15;
      --muted:#6b5f55;
      --card:#fffaf2;
      --line:#e7dccf;
      --shadow:0 12px 28px rgba(31,26,21,.10);
      --accent:#c65a2e;
      --chip:#f3e7d8;
      --focus:0 0 0 3px rgba(198,90,46,.22);
      --radius2:24px;
      --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      --sans:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    }
    *{box-sizing:border-box}
    html, body{height:100%} /* sticky safety */
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1100px 700px at 10% -10%, #ffe8cf 0%, transparent 60%),
        radial-gradient(900px 650px at 105% 0%, #d6f0ea 0%, transparent 55%),
        var(--bg);
    }
    header{
      position:sticky; top:0; z-index:10;
      backdrop-filter:blur(8px);
      background:rgba(251,246,238,.78);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    .brand{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .brand-left{display:flex;align-items:center;gap:12px}
    .mark{
      width:42px;height:42px;border-radius:14px;
      background:linear-gradient(145deg, rgba(198,90,46,.95), rgba(30,111,92,.9));
      box-shadow:0 10px 22px rgba(31,26,21,.12);
      position:relative;
    }
    .mark:after{
      content:""; position:absolute; inset:9px;
      border-radius:12px; background:rgba(251,246,238,.65);
      transform:rotate(10deg);
    }
    h1{font-size:16px;margin:0}
    .sub{margin:0;font-size:12px;color:var(--muted)}
    .cta-mini{display:flex;gap:10px;align-items:center;font-size:12px;color:var(--muted)}
    .pill{
      padding:8px 10px;border-radius:999px;background:var(--chip);
      border:1px solid var(--line);font-family:var(--mono)
    }

    main .wrap{
      padding:18px 16px 36px;
      display:grid;
      grid-template-columns: 460px 1fr;
      gap:18px;
      align-items:start;
      overflow: visible; /* sticky safety */
    }
    @media (max-width:980px){ main .wrap{grid-template-columns:1fr} }

    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--radius2);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card-head{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      display:flex;align-items:baseline;justify-content:space-between;gap:12px;
    }
    .card-head h2{margin:0;font-size:14px}
    .card-head .hint{font-size:12px;color:var(--muted)}
    .card-body{padding:14px 16px 16px}

    .grid{display:grid;gap:12px}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}

    select,input[type="text"],input[type="number"],input[type="range"],input[type="search"]{
      width:100%;
      padding:12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:#fff;
      color:var(--ink);
      outline:none;
    }
    input[type="range"]{height:42px;padding:10px}
    select:focus,input:focus{box-shadow:var(--focus);border-color:rgba(198,90,46,.55)}

    .row2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:560px){ .row2{grid-template-columns:1fr} }

    .divider{height:1px;background:var(--line);margin:12px 0}

    .btn{
      appearance:none;
      border:1px solid var(--line);
      background:#fff;
      color:var(--ink);
      border-radius:999px;
      padding:10px 12px;
      font-weight:600;
      cursor:pointer;
      transition:transform .05s ease, box-shadow .2s ease, background .2s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{transform:translateY(-1px);box-shadow:0 10px 20px rgba(31,26,21,.10)}
    .btn:active{transform:translateY(0);box-shadow:none}
    .btn.primary{
      border-color:rgba(198,90,46,.4);
      background:linear-gradient(135deg, rgba(198,90,46,.95), rgba(198,90,46,.78));
      color:#fff;
    }
    .btn.ghost{background:transparent}
    .btn.toggle-on{
      border-color:rgba(198,90,46,.35);
      background:rgba(198,90,46,.10);
    }

    .uploader{
      border:1px dashed rgba(31,26,21,.25);
      background:rgba(255,255,255,.6);
      border-radius:16px;
      padding:12px;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    .uploader .meta{display:flex;flex-direction:column;gap:3px;min-width:0}
    .uploader .meta b{font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .uploader .meta span{font-size:12px;color:var(--muted)}

    .chips{display:flex;flex-wrap:wrap;gap:8px}
    .chip{
      display:flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);background:#fff;
      cursor:pointer;font-size:12px;
    }
    .chip input{accent-color:var(--accent)}
    .swatch{width:12px;height:12px;border-radius:999px;border:1px solid rgba(31,26,21,.18)}

    details summary{
      cursor:pointer; user-select:none; list-style:none;
      font-size:12px; color:var(--muted);
      padding:10px 12px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.45);
      border-radius:16px;
    }
    details summary::-webkit-details-marker{display:none}
    details[open] summary{box-shadow:var(--focus);border-color:rgba(198,90,46,.35)}

    .note{
      background:rgba(30,111,92,.08);
      border:1px solid rgba(30,111,92,.18);
      padding:10px 12px;
      border-radius:16px;
      color:#164b3f;
      font-size:12px;
      line-height:1.35;
    }
    .warn{
      background:rgba(198,90,46,.08);
      border:1px solid rgba(198,90,46,.18);
      color:#6d2d17;
    }
    .small{font-size:12px;color:var(--muted)}
    .mono{font-family:var(--mono)}
    .sr{position:absolute;left:-9999px}

    /* Preview */
    .preview{display:block}

    /* ✅ FIX: sticky the GRID ITEM itself (Safari-friendly) */
    .preview{
      position: sticky;
      top: 92px;
      align-self: start;
      display: grid;
      justify-items: center;
    }

    /* keep wrapper non-sticky */
    .preview-sticky{
      position: static;
      top: auto;
      align-self: auto;
      display: block;
    }

    @media (max-width:980px){
      .preview{ position: static; top:auto; }
      .preview-sticky{ position: static; top:auto; }
    }

    .stage{padding:16px; width:100%;}
    .stage-top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px}
    .stage-top .title{display:flex;flex-direction:column;gap:2px}
    .stage-top .title b{font-size:14px}
    .stage-top .title span{font-size:12px;color:var(--muted)}

    .canvas-shell{
      width:100%;
      max-width: 720px;
      border-radius:26px;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.75), rgba(255,255,255,.25));
      padding:14px;
    }
    .canvas-inner{
      display:grid;place-items:center;
      background:rgba(31,26,21,.04);
      border-radius:20px;
      padding:18px;
      overflow:hidden;
      position:relative;
      touch-action:none;
    }
    canvas{
      width:min(520px, 92vw);
      height:auto;
      display:block;
      border-radius:18px;
      box-shadow:0 16px 28px rgba(31,26,21,.14);
      background:#fff;
    }

    .stage-actions{
      display:flex;flex-wrap:wrap;gap:10px;
      align-items:center;justify-content:space-between;
      margin-top:12px;
    }
    .stage-actions .left{display:flex;flex-wrap:wrap;gap:10px;align-items:center}

    .status{
      margin-top:10px;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.6);
      font-size:12px;color:var(--muted);line-height:1.35;
    }
    .status b{color:var(--ink)}

    /* Texture manager */
    .texture-list{display:grid;gap:10px;margin-top:10px}
    .tex-row{
      display:grid;
      grid-template-columns:1fr auto;
      gap:10px;
      align-items:center;
      padding:10px;
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(255,255,255,.55);
    }
    .tex-left{display:flex;gap:10px;align-items:center;min-width:0}
    .tex-thumb{
      width:44px;height:44px;border-radius:14px;
      border:1px solid var(--line);background:#fff;overflow:hidden;flex:0 0 auto;
    }
    .tex-thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .tex-meta{display:flex;flex-direction:column;gap:2px;min-width:0}
    .tex-meta b{font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .tex-meta span{font-size:12px;color:var(--muted)}
    .tex-actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end}

    /* Icon grid */
    .icon-grid{
      margin-top:10px;
      display:grid;
      grid-template-columns:repeat(6, 1fr);
      gap:8px;
    }
    @media (max-width:560px){ .icon-grid{grid-template-columns:repeat(4, 1fr)} }
    .icon-btn{
      border:1px solid var(--line);
      background:rgba(255,255,255,.7);
      border-radius:14px;
      padding:10px;
      display:grid;
      place-items:center;
      cursor:pointer;
      transition:transform .05s ease, box-shadow .2s ease;
      min-height:44px;
    }
    .icon-btn:hover{transform:translateY(-1px);box-shadow:0 10px 18px rgba(31,26,21,.10)}
    .icon-btn svg{width:22px;height:22px}
    .icon-meta{
      font-size:12px;color:var(--muted);
      margin-top:8px;
      display:flex;justify-content:space-between;gap:8px;
    }

    .uc-hidden{ position:absolute; left:-9999px; }
  </style>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&family=Playfair+Display:wght@400;600;700&family=Montserrat:wght@400;600;700&family=Poppins:wght@400;600;700&family=Raleway:wght@400;600;700&family=Oswald:wght@400;600&family=Bebas+Neue&family=Pacifico&family=Great+Vibes&family=Roboto+Slab:wght@400;600;700&family=Source+Serif+4:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">

  <script>
    UPLOADCARE_PUBLIC_KEY = "53eeccec14419f6dd5c8";
    UPLOADCARE_LOCALE = "en";
    UPLOADCARE_TABS = "file url camera";
  </script>
  <script src="https://ucarecdn.com/libs/widget/3.x/uploadcare.full.min.js" charset="utf-8"></script>
</head>

<body>
<header>
  <div class="wrap">
    <div class="brand">
      <div class="brand-left">
        <div class="mark" aria-hidden="true"></div>
        <div>
          <h1>Nice Coasters</h1>
          <p class="sub">Click blank space to deselect · Text: side handles = width · corner handles = font size · curve handle = bend</p>
        </div>
      </div>
      <div class="cta-mini">
        <span class="pill">Sticky preview</span>
        <span class="pill">Text-box curve</span>
        <span class="pill">PS-style handles</span>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="wrap">

    <!-- Controls -->
    <section class="card">
      <div class="card-head">
        <h2>Design</h2>
        <div class="hint">Select objects in preview</div>
      </div>

      <div class="card-body">
        <div class="grid">

          <div class="row2">
            <div>
              <label for="shape">Shape</label>
              <select id="shape">
                <option value="round">Round</option>
                <option value="square">Square</option>
                <option value="hex">Hex</option>
              </select>
            </div>
            <div>
              <label for="size">Size</label>
              <select id="size">
                <option value="3.5">3.5"</option>
                <option value="4.0" selected>4.0"</option>
                <option value="4.5">4.5"</option>
              </select>
            </div>
          </div>

          <div>
            <label>Material</label>
            <div class="chips" id="materials"></div>
          </div>

          <details>
            <summary>Material texture photos (optional)</summary>
            <div class="small" style="margin-top:8px;">
              Upload your real wood/slate photos here (saved in your browser). These textures appear behind the engraving preview.
            </div>
            <div class="texture-list" id="textureList"></div>
            <div class="note" style="margin-top:10px;">Tip: square-ish photos (800×800+) look best.</div>
          </details>

          <div class="divider"></div>

          <input
            id="ucUploader"
            class="uc-hidden"
            type="hidden"
            role="uploadcare-uploader"
            data-clearable="true"
            data-images-only="true"
            data-preview-step="true"
            data-image-shrink="2200x2200"
          />

          <div>
            <label>Logo / Artwork overlay</label>

            <div class="uploader">
              <div class="meta">
                <b id="artName">No file uploaded yet</b>
                <span>Opens Uploadcare box</span>
              </div>
              <div>
                <button type="button" class="btn" id="artPick">Upload</button>
              </div>
            </div>

            <div class="row2" style="margin-top:10px;">
              <button type="button" class="btn ghost" id="fitArtwork">Fit</button>
              <button type="button" class="btn ghost" id="clearArtwork">Clear</button>
            </div>

            <div class="note warn" style="margin-top:10px;">
              Best results: high-contrast artwork. Light/white areas won't "burn" and can disappear (like a real laser).
            </div>
          </div>

          <div class="divider"></div>

          <div>
            <label>SVG-style icons (Tabler)</label>
            <div class="row2">
              <input id="iconSearch" type="search" placeholder="Search icons… (e.g., coffee, heart, leaf, star)" />
              <button type="button" class="btn" id="iconSearchBtn">Search</button>
            </div>

            <div class="icon-grid" id="iconGrid"></div>

            <div class="icon-meta">
              <span id="iconStatus">Search to load icons.</span>
              <span class="mono" id="iconPicked">—</span>
            </div>

            <div class="row2" style="margin-top:10px;">
              <button type="button" class="btn ghost" id="fitIcon">Fit icon</button>
              <button type="button" class="btn ghost" id="clearIcon">Clear icon</button>
            </div>
          </div>

          <div class="divider"></div>

          <div>
            <label>Text line 1</label>
            <div class="row2">
              <input id="t1Text" type="text" placeholder="e.g., NICE COASTERS" value="" />
              <select id="t1Font"></select>
            </div>

            <div class="row2" style="margin-top:10px;">
              <div>
                <label for="t1Arch">Arch (optional)</label>
                <input id="t1Arch" type="range" min="-100" max="100" value="0" />
              </div>
              <div>
                <label>Orientation</label>
                <div class="row2" style="gap:8px">
                  <button type="button" class="btn toggle-on" id="t1Horiz">Horizontal</button>
                  <button type="button" class="btn" id="t1Vert">Vertical (ladder)</button>
                </div>
              </div>
            </div>

            <div class="note" style="margin-top:10px;">
              Select the text in the preview: <b>side handles</b> change width, <b>corner handles</b> change font size.
            </div>
          </div>

          <div>
            <label>Text line 2</label>
            <div class="row2">
              <input id="t2Text" type="text" placeholder="e.g., HANDMADE USA" value="" />
              <select id="t2Font"></select>
            </div>

            <div class="row2" style="margin-top:10px;">
              <div>
                <label for="t2Arch">Arch (optional)</label>
                <input id="t2Arch" type="range" min="-100" max="100" value="0" />
              </div>
              <div>
                <label>Orientation</label>
                <div class="row2" style="gap:8px">
                  <button type="button" class="btn toggle-on" id="t2Horiz">Horizontal</button>
                  <button type="button" class="btn" id="t2Vert">Vertical (ladder)</button>
                </div>
              </div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="note">Proof/export automatically hides selection boxes.</div>

        </div>
      </div>
    </section>

    <!-- Preview (sticky + centered) -->
    <section class="preview">
      <div class="preview-sticky">
        <section class="card stage">
          <div class="stage-top">
            <div class="title">
              <b>Preview</b>
              <span>Laser-style engraving simulation (dark burn look)</span>
            </div>
            <div class="small mono" id="summary"></div>
          </div>

          <div class="canvas-shell">
            <div class="canvas-inner" id="canvasWrap">
              <canvas id="cv" width="900" height="900" aria-label="Coaster preview"></canvas>
            </div>
          </div>

          <div class="stage-actions">
            <div class="left">
              <button type="button" class="btn" id="downloadPng">Download proof PNG</button>
              <button type="button" class="btn" id="copyCode">Copy order code</button>
              <button type="button" class="btn primary" id="submitDesign">Submit (host proof)</button>
            </div>
            <div class="small">Tip: double-click/tap to cycle selection</div>
          </div>

          <div class="status" id="statusBox">
            <b>Status:</b> Ready.
          </div>
        </section>
      </div>
    </section>

  </div>
</main>

<script>
/* =========================================================
   CONFIG / DATA
   ========================================================= */
const MATERIALS = [
  { id:"birch",  name:"Birch",  tone:"#e7d2b3" },
  { id:"walnut", name:"Walnut", tone:"#6a4b34" },
  { id:"bamboo", name:"Bamboo", tone:"#d9c38f" },
  { id:"cork",   name:"Cork",   tone:"#c2a47a" },
  { id:"slate",  name:"Slate",  tone:"#4b4d52" }
];

const FONT_OPTIONS = [
  { name:"Classic Serif (Playfair)", css:`"Playfair Display", Georgia, serif` },
  { name:"Book Serif (Source Serif)", css:`"Source Serif 4", Georgia, serif` },
  { name:"Warm Serif (Libre Baskerville)", css:`"Libre Baskerville", Georgia, serif` },
  { name:"Slab (Roboto Slab)", css:`"Roboto Slab", Georgia, serif` },
  { name:"Modern Sans (Montserrat)", css:`Montserrat, system-ui, sans-serif` },
  { name:"Clean Sans (Poppins)", css:`Poppins, system-ui, sans-serif` },
  { name:"Elegant Sans (Raleway)", css:`Raleway, system-ui, sans-serif` },
  { name:"Bold Display (Oswald)", css:`Oswald, system-ui, sans-serif` },
  { name:"ALL CAPS (Bebas Neue)", css:`"Bebas Neue", system-ui, sans-serif` },
  { name:"Script (Pacifico)", css:`Pacifico, cursive` },
  { name:"Fancy Script (Great Vibes)", css:`"Great Vibes", cursive` },
  { name:"Mono (IBM Plex Mono)", css:`"IBM Plex Mono", ui-monospace, monospace` },
  { name:"System (Default)", css:`system-ui, -apple-system, Segoe UI, Roboto, sans-serif` },
];

const KEYS = { textures: "nicecoasters_material_textures_v1" };
const $ = (id)=>document.getElementById(id);

/* =========================================================
   DOM
   ========================================================= */
const cv = $("cv");
const ctx = cv.getContext("2d");
const canvasWrap = $("canvasWrap");

const elShape = $("shape");
const elSize  = $("size");
const summary = $("summary");

const ucInput = $("ucUploader");
const ucWidget = uploadcare.Widget(ucInput);

const artPick = $("artPick");
const artName = $("artName");
const fitArtworkBtn = $("fitArtwork");
const clearArtworkBtn = $("clearArtwork");

const iconSearch = $("iconSearch");
const iconSearchBtn = $("iconSearchBtn");
const iconGrid = $("iconGrid");
const iconStatus = $("iconStatus");
const iconPicked = $("iconPicked");
const fitIconBtn = $("fitIcon");
const clearIconBtn = $("clearIcon");

const t1Text = $("t1Text");
const t1Font = $("t1Font");
const t1Arch = $("t1Arch");
const t1Horiz = $("t1Horiz");
const t1Vert  = $("t1Vert");

const t2Text = $("t2Text");
const t2Font = $("t2Font");
const t2Arch = $("t2Arch");
const t2Horiz = $("t2Horiz");
const t2Vert  = $("t2Vert");

const downloadPng = $("downloadPng");
const copyCodeBtn = $("copyCode");
const submitDesign = $("submitDesign");
const statusBox = $("statusBox");

/* =========================================================
   STATE
   ========================================================= */
const state = {
  material: MATERIALS[0].id,
  shape: "round",
  size: 4.0,

  artUrl: "",
  artPreviewUrl: "",
  artImage: null,

  iconName: "",
  iconSvg: "",
  iconImage: null,

  artObj:  { x:0, y:0, s:1.10, rot:0 },
  iconObj: { x:0, y:0, s:0.70, rot:0 },

  // boxW = text box width (fraction of safe box width)
  line1: { text:"", font: FONT_OPTIONS[4].css, x:0, y:-0.25, s:0.35, rot:0, arch:0, orient:"h", boxW:0.78 },
  line2: { text:"", font: FONT_OPTIONS[2].css, x:0, y: 0.45, s:0.26, rot:0, arch:0, orient:"h", boxW:0.86 },

  selected: null,
  showSelection: true,

  textureMap: loadTextureMap(),
  textureImgCache: {}
};

const pointerState = {
  active: new Map(),
  lastTapTime: 0,
  lastCentroid: null,
  lastDist: 0
};

const transformState = {
  action: null,     // "move" | "scale" | "rotate" | "curve" | "textWidth" | "fontScale"
  start: null
};

/* =========================================================
   UI BUILD
   ========================================================= */
function populateFontSelect(sel, selectedCss){
  sel.innerHTML = "";
  FONT_OPTIONS.forEach((f)=>{
    const opt = document.createElement("option");
    opt.value = f.css;
    opt.textContent = f.name;
    opt.style.fontFamily = f.css;
    sel.appendChild(opt);
  });
  sel.value = selectedCss || FONT_OPTIONS[0].css;
  sel.style.fontFamily = sel.value;
}
populateFontSelect(t1Font, state.line1.font);
populateFontSelect(t2Font, state.line2.font);

const materialsWrap = $("materials");
MATERIALS.forEach((m, idx)=>{
  const lab = document.createElement("label");
  lab.className = "chip";
  lab.innerHTML = `
    <input type="radio" name="mat" value="${m.id}" ${idx===0?"checked":""} />
    <span class="swatch" style="background:${m.tone}"></span>
    <span>${m.name}</span>
  `;
  lab.addEventListener("change", ()=>{
    state.material = m.id;
    render();
  });
  materialsWrap.appendChild(lab);
});

const textureList = $("textureList");
function renderTextureManager(){
  textureList.innerHTML = "";
  MATERIALS.forEach((m)=>{
    const dataUrl = state.textureMap[m.id] || "";
    const row = document.createElement("div");
    row.className = "tex-row";
    row.innerHTML = `
      <div class="tex-left">
        <div class="tex-thumb">${dataUrl ? `<img alt="${m.name} texture" src="${dataUrl}">` : ""}</div>
        <div class="tex-meta">
          <b>${m.name} texture</b>
          <span>${dataUrl ? "Custom photo loaded" : "No custom photo (uses flat tone)"}</span>
        </div>
      </div>
      <div class="tex-actions">
        <input class="sr" type="file" accept="image/*" id="texFile_${m.id}">
        <button type="button" class="btn ghost" id="texUp_${m.id}">Upload</button>
        <button type="button" class="btn" id="texClr_${m.id}" ${dataUrl ? "" : "disabled"}>Clear</button>
      </div>
    `;
    textureList.appendChild(row);

    const f = row.querySelector(`#texFile_${m.id}`);
    const up = row.querySelector(`#texUp_${m.id}`);
    const clr = row.querySelector(`#texClr_${m.id}`);

    up.addEventListener("click", (e)=>{ e.preventDefault(); f.click(); });
    f.addEventListener("change", async ()=>{
      const file = f.files && f.files[0];
      if(!file) return;
      const url = await fileToDataURL(file);
      state.textureMap[m.id] = url;
      saveTextureMap(state.textureMap);
      state.textureImgCache[m.id] = null;
      renderTextureManager();
      render();
    });

    clr.addEventListener("click", ()=>{
      delete state.textureMap[m.id];
      saveTextureMap(state.textureMap);
      state.textureImgCache[m.id] = null;
      renderTextureManager();
      render();
    });
  });
}

/* =========================================================
   INPUTS
   ========================================================= */
elShape.addEventListener("change", ()=>{ state.shape = elShape.value; render(); });
elSize.addEventListener("change", ()=>{ state.size = parseFloat(elSize.value); render(); });

t1Text.addEventListener("input", ()=>{ state.line1.text = t1Text.value; render(); });
t2Text.addEventListener("input", ()=>{ state.line2.text = t2Text.value; render(); });

t1Font.addEventListener("change", ()=>{ state.line1.font = t1Font.value; t1Font.style.fontFamily = t1Font.value; render(); });
t2Font.addEventListener("change", ()=>{ state.line2.font = t2Font.value; t2Font.style.fontFamily = t2Font.value; render(); });

t1Arch.addEventListener("input", ()=>{ state.line1.arch = parseInt(t1Arch.value,10)/100; render(); });
t2Arch.addEventListener("input", ()=>{ state.line2.arch = parseInt(t2Arch.value,10)/100; render(); });

function setOrient(which, orient){
  const line = (which==="t1") ? state.line1 : state.line2;
  line.orient = orient;
  if(orient === "v"){
    line.arch = 0;
    if(which==="t1") t1Arch.value = "0";
    if(which==="t2") t2Arch.value = "0";
  }
  const hBtn = (which==="t1") ? t1Horiz : t2Horiz;
  const vBtn = (which==="t1") ? t1Vert  : t2Vert;
  hBtn.classList.toggle("toggle-on", orient==="h");
  vBtn.classList.toggle("toggle-on", orient==="v");
  render();
}
t1Horiz.addEventListener("click", ()=>setOrient("t1","h"));
t1Vert .addEventListener("click", ()=>setOrient("t1","v"));
t2Horiz.addEventListener("click", ()=>setOrient("t2","h"));
t2Vert .addEventListener("click", ()=>setOrient("t2","v"));

fitArtworkBtn.addEventListener("click", ()=>{
  if(!state.artImage){ setStatus("Upload artwork first.", true); return; }
  state.selected = "art";
  fitArtworkToCoaster();
  render();
});
clearArtworkBtn.addEventListener("click", ()=>{
  state.artUrl = "";
  state.artPreviewUrl = "";
  state.artImage = null;
  artName.textContent = "No file uploaded yet";
  if(state.selected==="art") state.selected = null;
  render();
});

/* =========================================================
   UPLOADCARE
   ========================================================= */
function hasPublicKey(){
  return typeof UPLOADCARE_PUBLIC_KEY === "string" && UPLOADCARE_PUBLIC_KEY.trim().length > 6;
}
artPick.addEventListener("click", async (e)=>{
  e.preventDefault();
  if(!hasPublicKey()){
    setStatus("Missing Uploadcare public key.", true);
    return;
  }
  try{ await ucWidget.openDialog().done(()=>{}); }catch{}
});

ucWidget.onUploadComplete(async (info)=>{
  try{
    setStatus("Loading artwork…", false);
    const cdn = info.cdnUrl;
    state.artUrl = cdn;
    state.artPreviewUrl = cdn + "-/preview/1800x1800/";
    artName.textContent = (info.name || "Artwork uploaded");
    await loadImageIntoState(state.artPreviewUrl, "art");
    state.selected = "art";
    fitArtworkToCoaster();
    setStatus("Artwork loaded. Drag/resize/rotate in preview.", false);
    render();
  }catch(err){
    console.error(err);
    setStatus("Could not load uploaded image into preview.", true);
  }
});

async function loadImageIntoState(url, which){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = ()=>{
      if(which==="art") state.artImage = img;
      resolve();
    };
    img.onerror = ()=>reject(new Error("Could not load image."));
    img.src = url;
  });
}

function fitArtworkToCoaster(){
  state.artObj.x = 0;
  state.artObj.y = 0;
  state.artObj.s = 1.10;
  state.artObj.rot = 0;
}

/* =========================================================
   ICONS
   ========================================================= */
async function iconSearchRun(){
  const q = (iconSearch.value || "").trim();
  if(!q){
    iconStatus.textContent = "Type a search, like: coffee, heart, leaf…";
    iconGrid.innerHTML = "";
    return;
  }
  iconStatus.textContent = "Searching icons…";
  iconGrid.innerHTML = "";

  try{
    const url = `https://api.iconify.design/search?query=${encodeURIComponent(q)}&prefix=tabler&limit=48`;
    const res = await fetch(url);
    if(!res.ok) throw new Error("Icon search failed.");
    const data = await res.json();

    const icons = (data && data.icons) ? data.icons : [];
    if(!icons.length){
      iconStatus.textContent = "No results. Try a different keyword.";
      return;
    }
    iconStatus.textContent = `Results: ${Math.min(icons.length,48)} (Tabler)`;

    const frag = document.createDocumentFragment();
    for(const full of icons.slice(0,48)){
      const name = full.split(":")[1] || full;
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "icon-btn";
      btn.title = `tabler:${name}`;
      btn.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true"><path d=""/></svg>`;

      fetch(`https://api.iconify.design/tabler/${encodeURIComponent(name)}.svg?color=%231f1a15`)
        .then(r=>r.ok ? r.text() : "")
        .then(svg=>{ if(svg) btn.innerHTML = svg; });

      btn.addEventListener("click", ()=> pickIcon(name));
      frag.appendChild(btn);
    }
    iconGrid.appendChild(frag);
  }catch(e){
    console.error(e);
    iconStatus.textContent = "Icon search error. Check your connection.";
  }
}

iconSearchBtn.addEventListener("click", iconSearchRun);
iconSearch.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); iconSearchRun(); } });

async function pickIcon(name){
  try{
    setStatus("Loading icon…", false);
    const svgUrl = `https://api.iconify.design/tabler/${encodeURIComponent(name)}.svg?color=%23000000`;
    const res = await fetch(svgUrl);
    if(!res.ok) throw new Error("Icon fetch failed.");
    const svg = await res.text();

    const img = await svgToImage(svg);

    state.iconName = `tabler:${name}`;
    state.iconSvg = svg;
    state.iconImage = img;

    iconPicked.textContent = state.iconName;

    state.selected = "icon";
    fitIconToCoaster();

    setStatus("Icon loaded. Drag/resize/rotate in preview.", false);
    render();
  }catch(e){
    console.error(e);
    setStatus("Could not load icon.", true);
  }
}

function fitIconToCoaster(){
  state.iconObj.x = 0;
  state.iconObj.y = 0;
  state.iconObj.s = 0.70;
  state.iconObj.rot = 0;
}

fitIconBtn.addEventListener("click", ()=>{
  if(!state.iconImage){ setStatus("Pick an icon first.", true); return; }
  state.selected = "icon";
  fitIconToCoaster();
  render();
});
clearIconBtn.addEventListener("click", ()=>{
  state.iconName = "";
  state.iconSvg = "";
  state.iconImage = null;
  iconPicked.textContent = "—";
  if(state.selected==="icon") state.selected = null;
  render();
});

function svgToImage(svgText){
  return new Promise((resolve, reject)=>{
    const blob = new Blob([svgText], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = ()=>{
      URL.revokeObjectURL(url);
      resolve(img);
    };
    img.onerror = ()=>{
      URL.revokeObjectURL(url);
      reject(new Error("SVG decode failed."));
    };
    img.src = url;
  });
}

/* =========================================================
   EXPORT + SUBMIT (Proof hides selection)
   ========================================================= */
async function exportProofPngDataURL(){
  const oldShow = state.showSelection;
  const oldSel = state.selected;

  state.showSelection = false;
  state.selected = null;
  render();

  const dataUrl = cv.toDataURL("image/png");

  state.showSelection = oldShow;
  state.selected = oldSel;
  render();

  return dataUrl;
}

downloadPng.addEventListener("click", async ()=>{
  const dataUrl = await exportProofPngDataURL();
  const a = document.createElement("a");
  a.download = "nice-coasters-proof.png";
  a.href = dataUrl;
  a.click();
});

copyCodeBtn.addEventListener("click", ()=> copyText(buildOrderCode(), copyCodeBtn, "Copied!"));

submitDesign.addEventListener("click", async ()=>{
  if(!hasPublicKey()){
    setStatus("Missing Uploadcare public key.", true);
    return;
  }
  try{
    setStatus("Uploading proof PNG…", false);
    const proofDataUrl = await exportProofPngDataURL();
    const proofBlob = dataURLToBlob(proofDataUrl);
    await uploadToUploadcare(proofBlob, "nice-coasters-proof.png");
    setStatus("Submitted! Proof hosted. Use the order code in checkout notes.", false);
  }catch(err){
    console.error(err);
    setStatus(err.message || "Proof upload failed.", true);
  }
});

async function uploadToUploadcare(fileOrBlob, filename){
  const pub = (UPLOADCARE_PUBLIC_KEY || "").trim();
  if(!pub) throw new Error("Missing Uploadcare public key.");
  const fd = new FormData();
  fd.append("UPLOADCARE_PUB_KEY", pub);
  fd.append("UPLOADCARE_STORE", "1");
  fd.append("file", fileOrBlob, filename || "upload.bin");

  const res = await fetch("https://upload.uploadcare.com/base/", { method:"POST", body:fd });
  if(!res.ok){
    const txt = await res.text().catch(()=> "");
    throw new Error(`Upload failed (${res.status}). ${txt.slice(0,200)}`);
  }
  const data = await res.json();
  if(!data || !data.file) throw new Error("Uploadcare response missing file UUID.");
  return `https://ucarecdn.com/${data.file}/`;
}

function dataURLToBlob(dataURL){
  const [head, body] = dataURL.split(",");
  const mime = (head.match(/data:(.*?);base64/)||[])[1] || "application/octet-stream";
  const bin = atob(body);
  const len = bin.length;
  const bytes = new Uint8Array(len);
  for(let i=0;i<len;i++) bytes[i] = bin.charCodeAt(i);
  return new Blob([bytes], { type: mime });
}

/* =========================================================
   CANVAS INTERACTION
   - Blank click deselects
   - TEXT: side handles ONLY width, corners ONLY font size
   ========================================================= */
function getCanvasClientRect(){ return cv.getBoundingClientRect(); }
function canvasToLocal(px, py){
  const r = getCanvasClientRect();
  return {
    x: (px - r.left) * (cv.width / r.width),
    y: (py - r.top)  * (cv.height / r.height),
  };
}

function coasterGeom(){
  const pad = 85;
  const cx = cv.width/2;
  const cy = cv.height/2 + 10;
  const rr  = (cv.width - pad*2) * 0.43;
  return {cx, cy, r: rr};
}

function getSelectedObj(){
  if(state.selected === "art")  return state.artObj;
  if(state.selected === "icon") return state.iconObj;
  if(state.selected === "t1")   return state.line1;
  if(state.selected === "t2")   return state.line2;
  return null;
}
function isTextSelected(){ return state.selected === "t1" || state.selected === "t2"; }

function cycleSelection(){
  const order = ["art","icon","t1","t2"];
  const i = order.indexOf(state.selected);
  for(let k=1;k<=order.length;k++){
    const next = order[(i+k)%order.length];
    if(next==="art"  && !state.artImage) continue;
    if(next==="icon" && !state.iconImage) continue;
    state.selected = next;
    return;
  }
}

function pickObjectAtOrNull(x, y){
  const {cx, cy, r} = coasterGeom();
  const box = getSafeBox(cx, cy, r, state.shape);

  const cand = [];
  if(state.artImage) cand.push({id:"art"});
  if(state.iconImage) cand.push({id:"icon"});
  cand.push({id:"t1"});
  cand.push({id:"t2"});

  let best = {id:null, d:1e9};
  const thr = Math.min(box.w, box.h) * 0.14;

  for(const c of cand){
    const obj = (c.id==="t1") ? state.line1 :
                (c.id==="t2") ? state.line2 :
                (c.id==="art") ? state.artObj : state.iconObj;
    const p = normToLocalBox(obj.x, obj.y, box);
    const d = Math.hypot(x - p.x, y - p.y);
    if(d < best.d){ best = {id:c.id, d}; }
  }
  return (best.d < thr) ? best.id : null;
}

function getObjectRectInCanvas(box, id){
  const obj = (id==="t1") ? state.line1 :
              (id==="t2") ? state.line2 :
              (id==="art") ? state.artObj : state.iconObj;

  const c = normToLocalBox(obj.x, obj.y, box);
  const rot = obj.rot || 0;

  if(id==="art" || id==="icon"){
    const img = (id==="art") ? state.artImage : state.iconImage;
    if(!img) return { cx:c.x, cy:c.y, w:140, h:140, rot };

    const base = cover(img.width, img.height, box.w, box.h);
    const baseScale = (id==="icon") ? 0.55 : 1.00;
    const w = base.w * baseScale * obj.s;
    const h = base.h * baseScale * obj.s;
    return { cx:c.x, cy:c.y, w, h, rot };
  }

  const basePx = 120;
  const px = clamp(Math.round(basePx * obj.s), 12, 220);
  const isV = obj.orient === "v";

  if(isV){
    const chars = [...((obj.text||"").trim())];
    const lineH = px * 1.05;
    const count = Math.max(1, chars.length);
    const h = count * lineH + 26;
    const w = Math.max(44, px + 22);
    return { cx:c.x, cy:c.y, w, h, rot };
  } else {
    const desiredW = clamp(obj.boxW || 0.78, 0.20, 1.20) * box.w;
    const w = Math.max(90, desiredW);
    const h = Math.max(54, px + 30);
    return { cx:c.x, cy:c.y, w, h, rot };
  }
}

function rotRectHandlePoints(cx, cy, w, h, rot){
  const pts = [
    {x:-w/2,y:-h/2}, {x:0,y:-h/2}, {x:w/2,y:-h/2},
    {x:w/2,y:0},
    {x:w/2,y:h/2}, {x:0,y:h/2}, {x:-w/2,y:h/2},
    {x:-w/2,y:0},
  ];
  return pts.map(p=>{
    const xr = p.x*Math.cos(rot) - p.y*Math.sin(rot);
    const yr = p.x*Math.sin(rot) + p.y*Math.cos(rot);
    return { x: cx + xr, y: cy + yr };
  });
}
function rotateHandlePoint(x,y,cx,cy,offset){
  const vx = x - cx, vy = y - cy;
  const len = Math.max(1, Math.hypot(vx,vy));
  return { x: x + (vx/len)*offset, y: y + (vy/len)*offset };
}
function hitTestHandle(px, py, hx, hy, r=14){
  return Math.hypot(px-hx, py-hy) <= r;
}
function sideHandlesForText(rect){
  const pts = rotRectHandlePoints(rect.cx, rect.cy, rect.w, rect.h, rect.rot||0);
  return { left: pts[7], right: pts[3] };
}
function curveHandlePointForText(rect){
  const pts = rotRectHandlePoints(rect.cx, rect.cy, rect.w, rect.h, rect.rot||0);
  const topMid = pts[1];
  return rotateHandlePoint(topMid.x, topMid.y, rect.cx, rect.cy, 54);
}

function hitTestSelection(loc, box){
  if(!state.selected) return { action:null, rect:null, handleIndex:-1 };

  const id = state.selected;
  const rect = getObjectRectInCanvas(box, id);
  const rot = rect.rot || 0;
  const handles = rotRectHandlePoints(rect.cx, rect.cy, rect.w, rect.h, rot);

  // rotate handle (all)
  const topMid = handles[1];
  const rotH = rotateHandlePoint(topMid.x, topMid.y, rect.cx, rect.cy, 26);
  if(hitTestHandle(loc.x,loc.y, rotH.x, rotH.y, 16)){
    return { action:"rotate", rect, handleIndex:-1 };
  }

  // TEXT SPECIAL:
  if(isTextSelected()){
    const obj = getSelectedObj();

    // side handles ONLY width (horizontal only)
    if(obj && obj.orient === "h"){
      const sh = sideHandlesForText(rect);
      if(hitTestHandle(loc.x,loc.y, sh.left.x, sh.left.y, 16) || hitTestHandle(loc.x,loc.y, sh.right.x, sh.right.y, 16)){
        return { action:"textWidth", rect, handleIndex:-1 };
      }

      // curve handle
      const ch = curveHandlePointForText(rect);
      if(hitTestHandle(loc.x,loc.y, ch.x, ch.y, 16)){
        return { action:"curve", rect, handleIndex:-1 };
      }
    }

    // corner handles ONLY font size
    const cornerIdx = [0,2,4,6];
    for(const i of cornerIdx){
      if(hitTestHandle(loc.x,loc.y, handles[i].x, handles[i].y, 14)){
        return { action:"fontScale", rect, handleIndex:i };
      }
    }

    // inside => move
    const d = Math.hypot(loc.x-rect.cx, loc.y-rect.cy);
    if(d < Math.max(rect.w,rect.h)*0.65){
      return { action:"move", rect, handleIndex:-1 };
    }

    return { action:null, rect, handleIndex:-1 };
  }

  // non-text: any handle scales
  for(let i=0;i<handles.length;i++){
    if(hitTestHandle(loc.x,loc.y, handles[i].x, handles[i].y, 14)){
      return { action:"scale", rect, handleIndex:i };
    }
  }

  // inside => move
  const d = Math.hypot(loc.x-rect.cx, loc.y-rect.cy);
  if(d < Math.max(rect.w,rect.h)*0.65){
    return { action:"move", rect, handleIndex:-1 };
  }

  return { action:null, rect, handleIndex:-1 };
}

/* Pointer events */
canvasWrap.addEventListener("pointerdown", (e)=>{
  cv.setPointerCapture(e.pointerId);

  const now = performance.now();
  const isDouble = (now - pointerState.lastTapTime) < 320;
  pointerState.lastTapTime = now;

  const loc = canvasToLocal(e.clientX, e.clientY);
  const {cx, cy, r} = coasterGeom();
  const box = getSafeBox(cx, cy, r, state.shape);

  if(isDouble){
    if(state.selected) cycleSelection();
    else state.selected = pickObjectAtOrNull(loc.x, loc.y);
    render();
  }else{
    state.selected = pickObjectAtOrNull(loc.x, loc.y); // blank => null (deselect)
    render();
  }

  if(!state.selected){
    transformState.action = null;
    transformState.start = null;
    pointerState.active.set(e.pointerId, {x:e.clientX, y:e.clientY});
    return;
  }

  const ht = hitTestSelection(loc, box);
  if(ht.action){
    const obj = getSelectedObj();
    transformState.action = ht.action;
    transformState.start = {
      x: loc.x, y: loc.y,
      obj: { x: obj.x, y: obj.y, s: obj.s, rot: obj.rot || 0, arch: obj.arch || 0, boxW: obj.boxW || 0.78 },
      rect: ht.rect
    };
  }else{
    transformState.action = null;
    transformState.start = null;
  }

  pointerState.active.set(e.pointerId, {x:e.clientX, y:e.clientY});
  if(pointerState.active.size === 2){
    const pts = [...pointerState.active.values()];
    pointerState.lastCentroid = {x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2};
    pointerState.lastDist = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
  }else{
    pointerState.lastCentroid = {x:e.clientX, y:e.clientY};
    pointerState.lastDist = 0;
  }
});

canvasWrap.addEventListener("pointermove", (e)=>{
  if(!pointerState.active.has(e.pointerId)) return;
  pointerState.active.set(e.pointerId, {x:e.clientX, y:e.clientY});

  if(!state.selected) return;

  const loc = canvasToLocal(e.clientX, e.clientY);
  const {cx, cy, r} = coasterGeom();
  const box = getSafeBox(cx, cy, r, state.shape);

  // Single pointer transforms
  if(transformState.action && transformState.start && pointerState.active.size === 1){
    const obj = getSelectedObj();
    if(!obj) return;

    if(transformState.action === "move"){
      const dx = loc.x - transformState.start.x;
      const dy = loc.y - transformState.start.y;
      obj.x = clamp(transformState.start.obj.x + dx/(box.w/2), -1.2, 1.2);
      obj.y = clamp(transformState.start.obj.y + dy/(box.h/2), -1.2, 1.2);
      render();
      return;
    }

    if(transformState.action === "rotate"){
      const c = normToLocalBox(transformState.start.obj.x, transformState.start.obj.y, box);
      const a0 = Math.atan2(transformState.start.y - c.y, transformState.start.x - c.x);
      const a1 = Math.atan2(loc.y - c.y, loc.x - c.x);
      obj.rot = transformState.start.obj.rot + (a1 - a0);
      render();
      return;
    }

    if(transformState.action === "scale"){
      const c = normToLocalBox(transformState.start.obj.x, transformState.start.obj.y, box);
      const d0 = Math.hypot(transformState.start.x - c.x, transformState.start.y - c.y);
      const d1 = Math.hypot(loc.x - c.x, loc.y - c.y);
      const factor = (d0>2) ? (d1/d0) : 1;

      const minS = (state.selected==="art") ? 0.25 : (state.selected==="icon") ? 0.15 : 0.10;
      const maxS = (state.selected==="art") ? 4.0  : (state.selected==="icon") ? 3.0  : 1.10;
      obj.s = clamp(transformState.start.obj.s * factor, minS, maxS);
      render();
      return;
    }

    if(transformState.action === "fontScale" && isTextSelected()){
      const c = normToLocalBox(transformState.start.obj.x, transformState.start.obj.y, box);
      const d0 = Math.hypot(transformState.start.x - c.x, transformState.start.y - c.y);
      const d1 = Math.hypot(loc.x - c.x, loc.y - c.y);
      const factor = (d0>2) ? (d1/d0) : 1;

      obj.s = clamp(transformState.start.obj.s * factor, 0.08, 1.20);
      render();
      return;
    }

    if(transformState.action === "textWidth" && isTextSelected()){
      if(obj.orient !== "h") return;

      const dx = loc.x - transformState.start.x;
      const dy = loc.y - transformState.start.y;
      const rot = transformState.start.obj.rot || 0;
      const localX =  (dx * Math.cos(-rot)) - (dy * Math.sin(-rot));
      const deltaNorm = (localX * 2) / box.w;

      obj.boxW = clamp(transformState.start.obj.boxW + deltaNorm, 0.20, 1.20);
      render();
      return;
    }

    if(transformState.action === "curve" && isTextSelected()){
      if(obj.orient !== "h") return;

      const rect = transformState.start.rect;
      const ch = curveHandlePointForText(rect);
      const dy = (loc.y - ch.y);

      const scale = clamp01(Math.abs(dy) / (Math.max(80, rect.h*0.6)));
      let val = -dy >= 0 ? scale : -scale;
      val = clamp(val, -1, 1);

      obj.arch = val;
      if(state.selected==="t1") t1Arch.value = String(Math.round(val*100));
      if(state.selected==="t2") t2Arch.value = String(Math.round(val*100));
      render();
      return;
    }
  }

  // Pinch pan/zoom with 2 pointers (kept for convenience)
  if(pointerState.active.size === 2){
    const obj = getSelectedObj();
    if(!obj) return;

    const pts = [...pointerState.active.values()];
    const cNow = {x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2};
    const dNow = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);

    if(pointerState.lastCentroid){
      const dx = cNow.x - pointerState.lastCentroid.x;
      const dy = cNow.y - pointerState.lastCentroid.y;
      const rect = getCanvasClientRect();
      const dxCanvas = dx * (cv.width / rect.width);
      const dyCanvas = dy * (cv.height / rect.height);
      obj.x = clamp(obj.x + dxCanvas/(box.w/2), -1.2, 1.2);
      obj.y = clamp(obj.y + dyCanvas/(box.h/2), -1.2, 1.2);
    }
    if(pointerState.lastDist > 0){
      const ratio = dNow / pointerState.lastDist;
      const minS = (state.selected==="art") ? 0.25 : (state.selected==="icon") ? 0.15 : isTextSelected() ? 0.08 : 0.10;
      const maxS = (state.selected==="art") ? 4.0  : (state.selected==="icon") ? 3.0  : isTextSelected() ? 1.20 : 1.10;
      obj.s = clamp(obj.s * ratio, minS, maxS);
    }

    pointerState.lastCentroid = cNow;
    pointerState.lastDist = dNow;
    render();
    return;
  }
});

canvasWrap.addEventListener("pointerup", (e)=>{
  pointerState.active.delete(e.pointerId);
  if(pointerState.active.size < 2){
    pointerState.lastCentroid = null;
    pointerState.lastDist = 0;
  }
  if(pointerState.active.size === 0){
    transformState.action = null;
    transformState.start = null;
  }
});

canvasWrap.addEventListener("wheel", (e)=>{
  e.preventDefault();
  const obj = getSelectedObj();
  if(!obj) return;
  const delta = Math.sign(e.deltaY);
  const factor = (delta > 0) ? 0.94 : 1.06;

  const minS = (state.selected==="art") ? 0.25 : (state.selected==="icon") ? 0.15 : isTextSelected() ? 0.08 : 0.10;
  const maxS = (state.selected==="art") ? 4.0  : (state.selected==="icon") ? 3.0  : isTextSelected() ? 1.20 : 1.10;
  obj.s = clamp(obj.s * factor, minS, maxS);

  render();
},{passive:false});

/* =========================================================
   ORDER CODE
   ========================================================= */
function buildOrderCode(){
  const safe = (s)=>String(s||"").replace(/\|/g,"/").trim().slice(0,80);
  const f1 = shortenFont(state.line1.font);
  const f2 = shortenFont(state.line2.font);

  return [
    "NICECOASTERS4",
    `mat:${state.material}`,
    `shape:${state.shape}`,
    `size:${state.size.toFixed(1)}`,

    `art:${state.artImage ? 1:0}`,
    `ax:${state.artObj.x.toFixed(3)}`,
    `ay:${state.artObj.y.toFixed(3)}`,
    `as:${state.artObj.s.toFixed(3)}`,
    `ar:${(state.artObj.rot||0).toFixed(3)}`,

    `ic:${state.iconImage ? safe(state.iconName):"none"}`,
    `ix:${state.iconObj.x.toFixed(3)}`,
    `iy:${state.iconObj.y.toFixed(3)}`,
    `is:${state.iconObj.s.toFixed(3)}`,
    `ir:${(state.iconObj.rot||0).toFixed(3)}`,

    `f1:${f1}`,`t1:${safe(state.line1.text)}`,
    `x1:${state.line1.x.toFixed(3)}`,`y1:${state.line1.y.toFixed(3)}`,`s1:${state.line1.s.toFixed(3)}`,
    `r1:${(state.line1.rot||0).toFixed(3)}`,`a1:${(state.line1.arch||0).toFixed(2)}`,`o1:${state.line1.orient}`,`w1:${(state.line1.boxW||0.78).toFixed(3)}`,

    `f2:${f2}`,`t2:${safe(state.line2.text)}`,
    `x2:${state.line2.x.toFixed(3)}`,`y2:${state.line2.y.toFixed(3)}`,`s2:${state.line2.s.toFixed(3)}`,
    `r2:${(state.line2.rot||0).toFixed(3)}`,`a2:${(state.line2.arch||0).toFixed(2)}`,`o2:${state.line2.orient}`,`w2:${(state.line2.boxW||0.86).toFixed(3)}`
  ].join("|");
}
function shortenFont(font){
  return (font||"").split(",")[0].replace(/['"]/g,"").trim().slice(0,18);
}

/* =========================================================
   RENDER
   ========================================================= */
function render(){
  const mat = MATERIALS.find(m=>m.id===state.material) || MATERIALS[0];
  summary.textContent = `${mat.name} · ${state.shape} · ${state.size.toFixed(1)}" · sel:${state.selected || "none"}`;

  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.fillStyle = "#f7efe4";
  ctx.fillRect(0,0,cv.width,cv.height);

  const {cx, cy, r} = coasterGeom();
  drawMaterialBase(cx, cy, r, mat);

  const engr = document.createElement("canvas");
  engr.width = cv.width;
  engr.height= cv.height;
  const ectx = engr.getContext("2d");

  ectx.save();
  clipShape(ectx, cx, cy, r, state.shape);

  const box = getSafeBox(cx, cy, r, state.shape);

  if (state.artImage) drawImageObj(ectx, box, state.artImage, state.artObj, 1.00);
  if (state.iconImage) drawImageObj(ectx, box, state.iconImage, state.iconObj, 0.55);

  drawTextBoxed(ectx, box, state.line1);
  drawTextBoxed(ectx, box, state.line2);

  ectx.restore();

  const mask = toEngraveMask(engr);
  applyEngraving(mask, cx, cy, r, state.shape);
  drawEdge(cx, cy, r, state.shape);

  if(state.showSelection && state.selected){
    drawSelectionBox(box);
  }

  ctx.save();
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "#1f1a15";
  ctx.font = `14px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign = "center";
  ctx.fillText("nice coasters preview", cx, cv.height - 28);
  ctx.restore();
}

function drawImageObj(ectx, box, img, obj, baseScale){
  const base = cover(img.width, img.height, box.w, box.h);
  const w = base.w * baseScale * obj.s;
  const h = base.h * baseScale * obj.s;
  const center = normToLocalBox(obj.x, obj.y, box);

  ectx.save();
  ectx.translate(center.x, center.y);
  ectx.rotate(obj.rot || 0);
  ectx.drawImage(img, -w/2, -h/2, w, h);
  ectx.restore();
}

function drawTextBoxed(ectx, box, line){
  const t = (line.text || "").trim();
  if(!t) return;

  const p = normToLocalBox(line.x, line.y, box);
  const basePx = 120;
  const px = clamp(Math.round(basePx * line.s), 12, 220);

  ectx.save();
  ectx.translate(p.x, p.y);
  ectx.rotate(line.rot || 0);

  ectx.fillStyle = "#000";
  ectx.textAlign = "center";
  ectx.textBaseline = "middle";
  ectx.font = `${px}px ${line.font}`;

  // Vertical ladder
  if(line.orient === "v"){
    const chars = [...t];
    const lineH = px * 1.05;
    const totalH = (chars.length-1) * lineH;
    for(let i=0;i<chars.length;i++){
      ectx.fillText(chars[i], 0, -totalH/2 + i*lineH);
      ectx.fillText(chars[i], 0.6, -totalH/2 + i*lineH);
    }
    ectx.restore();
    return;
  }

  const desiredW = clamp(line.boxW || 0.78, 0.20, 1.20) * box.w;
  const rawW = ectx.measureText(t).width;
  const arch = clamp(line.arch || 0, -1, 1);

  // Straight text fits box via horizontal scaling
  if(Math.abs(arch) < 0.02){
    const scaleX = clamp(desiredW / Math.max(1, rawW), 0.55, 1.60);
    ectx.save();
    ectx.scale(scaleX, 1);
    ectx.fillText(t, 0, 0);
    ectx.fillText(t, 0.6/scaleX, 0);
    ectx.restore();
    ectx.restore();
    return;
  }

  // Arched text: box width defines chord length
  const maxSweep = degToRad(170);
  const sweep = clamp(arch, -1, 1) * maxSweep;
  const half = Math.max(0.001, Math.abs(sweep)/2);
  let R = desiredW / (2 * Math.sin(half));
  R = clamp(R, 40, 2000);

  const chars = [...t];
  const widths = chars.map(ch => ectx.measureText(ch).width);
  const totalW = widths.reduce((a,b)=>a+b,0);

  let ang = -sweep/2;
  for(let i=0;i<chars.length;i++){
    const frac = (totalW>0) ? (widths[i] / totalW) : (1/chars.length);
    const step = sweep * frac;
    const mid = ang + step/2;

    ectx.save();
    ectx.rotate(mid);
    ectx.translate(0, -R);
    ectx.rotate(sweep > 0 ? Math.PI/2 : -Math.PI/2);
    ectx.fillText(chars[i], 0, 0);
    ectx.restore();

    ang += step;
  }

  ectx.restore();
}

function drawSelectionBox(box){
  const id = state.selected;
  if(id==="art" && !state.artImage) return;
  if(id==="icon" && !state.iconImage) return;

  const r = getObjectRectInCanvas(box, id);
  const rot = r.rot || 0;

  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(31,26,21,.55)";
  ctx.setLineDash([6,4]);
  strokeRotRect(r.cx, r.cy, r.w, r.h, rot);
  ctx.setLineDash([]);

  const pts = rotRectHandlePoints(r.cx, r.cy, r.w, r.h, rot);

  // Rotate handle (all)
  const t = pts[1];
  const rh = rotateHandlePoint(t.x, t.y, r.cx, r.cy, 26);
  drawRotateHandle(rh.x, rh.y);
  ctx.strokeStyle = "rgba(31,26,21,.35)";
  ctx.beginPath();
  ctx.moveTo(t.x, t.y);
  ctx.lineTo(rh.x, rh.y);
  ctx.stroke();

  // Handles:
  if(isTextSelected()){
    // corners only (font size)
    [0,2,4,6].forEach(i => drawHandle(pts[i].x, pts[i].y));

    const obj = getSelectedObj();
    if(obj && obj.orient === "h"){
      // side width handles
      const sh = sideHandlesForText(r);
      drawWidthHandle(sh.left.x, sh.left.y);
      drawWidthHandle(sh.right.x, sh.right.y);

      // curve handle
      const ch = curveHandlePointForText(r);
      ctx.strokeStyle = "rgba(31,26,21,.22)";
      ctx.beginPath();
      ctx.moveTo(rh.x, rh.y);
      ctx.lineTo(ch.x, ch.y);
      ctx.stroke();
      drawCurveHandle(ch.x, ch.y);
    }
  }else{
    // non-text: standard 8 handles (scale)
    pts.forEach(p => drawHandle(p.x,p.y));
  }

  ctx.restore();
}

function drawHandle(x,y){
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,.95)";
  ctx.strokeStyle = "rgba(31,26,21,.55)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.rect(x-7,y-7,14,14);
  ctx.fill(); ctx.stroke();
  ctx.restore();
}
function drawRotateHandle(x,y){
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,.95)";
  ctx.strokeStyle = "rgba(31,26,21,.55)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x,y,8,0,Math.PI*2);
  ctx.fill(); ctx.stroke();
  ctx.restore();
}
function drawCurveHandle(x,y){
  ctx.save();
  ctx.fillStyle = "rgba(198,90,46,.18)";
  ctx.strokeStyle = "rgba(198,90,46,.65)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x,y,9,0,Math.PI*2);
  ctx.fill(); ctx.stroke();
  ctx.restore();

  ctx.save();
  ctx.fillStyle = "rgba(198,90,46,.9)";
  ctx.font = "10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("∿", x, y+0.5);
  ctx.restore();
}
function drawWidthHandle(x,y){
  ctx.save();
  ctx.fillStyle = "rgba(30,111,92,.16)";
  ctx.strokeStyle = "rgba(30,111,92,.65)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x,y,8,0,Math.PI*2);
  ctx.fill(); ctx.stroke();
  ctx.restore();

  ctx.save();
  ctx.strokeStyle = "rgba(30,111,92,.85)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x-4,y);
  ctx.lineTo(x+4,y);
  ctx.stroke();
  ctx.restore();
}
function strokeRotRect(cx, cy, w, h, rot){
  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(rot);
  ctx.strokeRect(-w/2, -h/2, w, h);
  ctx.restore();
}

/* ---------------------------
   Laser look + base
--------------------------- */
function drawMaterialBase(cx, cy, r, mat){
  ctx.save();
  clipShape(ctx, cx, cy, r, state.shape);

  const tex = state.textureMap[mat.id];
  if (tex){
    const cached = state.textureImgCache[mat.id];
    if (cached){
      drawCover(ctx, cached, 0,0, cv.width, cv.height);
    } else {
      const img = new Image();
      img.onload = ()=>{ state.textureImgCache[mat.id] = img; render(); };
      img.src = tex;
      ctx.fillStyle = mat.tone;
      ctx.fillRect(0,0,cv.width,cv.height);
    }
  } else {
    ctx.fillStyle = mat.tone;
    ctx.fillRect(0,0,cv.width,cv.height);
  }

  const noise = makeNoisePattern(240, 240, 0.12);
  ctx.globalAlpha = 0.28;
  ctx.drawImage(noise, 0,0, cv.width, cv.height);

  const grad = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, r*1.25);
  grad.addColorStop(0, "rgba(255,255,255,0.10)");
  grad.addColorStop(1, "rgba(0,0,0,0.14)");
  ctx.globalAlpha = 1;
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,cv.width,cv.height);

  ctx.restore();
}

function toEngraveMask(srcCanvas){
  const w = srcCanvas.width, h = srcCanvas.height;
  const out = document.createElement("canvas");
  out.width = w; out.height = h;
  const octx = out.getContext("2d");

  const sctx = srcCanvas.getContext("2d");
  const img = sctx.getImageData(0,0,w,h);
  const d = img.data;

  for(let i=0;i<d.length;i+=4){
    const rr = d[i], gg=d[i+1], bb=d[i+2], aa=d[i+3];
    if(aa===0){ d[i+3]=0; continue; }
    const lum = (0.2126*rr + 0.7152*gg + 0.0722*bb) / 255;

    const whiteCut = 0.92;
    const softStart= 0.70;
    let alpha = 0;

    if(lum >= whiteCut){
      alpha = 0;
    }else if(lum <= softStart){
      const t = 1 - lum;
      alpha = clamp01((t - 0.05) / 0.95);
    }else{
      const k = (whiteCut - lum) / (whiteCut - softStart);
      alpha = clamp01(k * 0.55);
    }
    alpha = Math.pow(alpha, 0.85);

    d[i]=0; d[i+1]=0; d[i+2]=0;
    d[i+3]=Math.round(alpha*255);
  }
  octx.putImageData(img,0,0);

  octx.filter = "blur(0.7px)";
  const temp = document.createElement("canvas");
  temp.width=w; temp.height=h;
  temp.getContext("2d").drawImage(out,0,0);
  octx.clearRect(0,0,w,h);
  octx.drawImage(temp,0,0);
  octx.filter = "none";

  return out;
}

function applyEngraving(maskCanvas, cx, cy, r, shape){
  ctx.save();
  clipShape(ctx, cx, cy, r, shape);

  const darkLayer = document.createElement("canvas");
  darkLayer.width = cv.width;
  darkLayer.height= cv.height;
  const dctx = darkLayer.getContext("2d");
  dctx.fillStyle = "#2b1b12";
  dctx.fillRect(0,0,cv.width,cv.height);
  dctx.globalCompositeOperation = "destination-in";
  dctx.drawImage(maskCanvas, 0,0);

  ctx.globalAlpha = 0.92;
  ctx.drawImage(darkLayer, 0,0);

  ctx.globalAlpha = 0.16;
  ctx.globalCompositeOperation = "multiply";
  const charNoise = makeNoisePattern(420, 420, 0.26);
  ctx.drawImage(charNoise, 0,0, cv.width, cv.height);

  ctx.restore();
  ctx.globalCompositeOperation = "source-over";
  ctx.globalAlpha = 1;
}

function drawEdge(cx, cy, r, shape){
  ctx.save();
  ctx.lineWidth = 10;
  ctx.strokeStyle = "rgba(31,26,21,.22)";
  ctx.shadowColor = "rgba(31,26,21,.20)";
  ctx.shadowBlur = 18;
  ctx.shadowOffsetY = 10;
  drawShapePath(ctx, cx, cy, r, shape);
  ctx.stroke();

  ctx.shadowBlur = 0;
  ctx.lineWidth = 6;
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  drawShapePath(ctx, cx, cy, r*0.97, shape);
  ctx.stroke();
  ctx.restore();
}

/* =========================================================
   SHAPES / SAFE BOX
   ========================================================= */
function clipShape(c, cx, cy, r, shape){
  c.beginPath();
  if(shape === "round"){
    c.arc(cx, cy, r, 0, Math.PI*2);
  }else if(shape === "square"){
    const s = r*1.58;
    roundRectPath(c, cx - s/2, cy - s/2, s, s, r*0.16);
  }else{
    polygonPath(c, cx, cy, r*1.05, 6, -Math.PI/2);
  }
  c.closePath();
  c.clip();
}
function drawShapePath(c, cx, cy, r, shape){
  c.beginPath();
  if(shape === "round"){
    c.arc(cx, cy, r, 0, Math.PI*2);
  }else if(shape === "square"){
    const s = r*1.58;
    roundRectPath(c, cx - s/2, cy - s/2, s, s, r*0.16);
  }else{
    polygonPath(c, cx, cy, r*1.05, 6, -Math.PI/2);
  }
  c.closePath();
}
function getSafeBox(cx, cy, r, shape){
  if(shape === "round") return { x: cx - r*0.78, y: cy - r*0.78, w: r*1.56, h: r*1.56 };
  if(shape === "square"){
    const s = r*1.58;
    return { x: cx - s*0.42, y: cy - s*0.42, w: s*0.84, h: s*0.84 };
  }
  return { x: cx - r*0.78, y: cy - r*0.70, w: r*1.56, h: r*1.40 };
}
function normToLocalBox(nx, ny, box){
  return {
    x: box.x + box.w/2 + nx*(box.w/2),
    y: box.y + box.h/2 + ny*(box.h/2),
  };
}

/* =========================================================
   UTILS
   ========================================================= */
function roundRectPath(c, x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  c.moveTo(x+rr, y);
  c.arcTo(x+w, y, x+w, y+h, rr);
  c.arcTo(x+w, y+h, x, y+h, rr);
  c.arcTo(x, y+h, x, y, rr);
  c.arcTo(x, y, x+w, y, rr);
}
function polygonPath(c, cx, cy, radius, sides, rot){
  for(let i=0;i<sides;i++){
    const a = rot + i*(Math.PI*2/sides);
    const x = cx + Math.cos(a)*radius;
    const y = cy + Math.sin(a)*radius;
    if(i===0) c.moveTo(x,y); else c.lineTo(x,y);
  }
}
function cover(w,h, boxW, boxH){
  const s = Math.max(boxW/w, boxH/h);
  return { w:w*s, h:h*s };
}
function makeNoisePattern(w,h, strength){
  const c = document.createElement("canvas");
  c.width=w; c.height=h;
  const x = c.getContext("2d");
  const img = x.createImageData(w,h);
  const d = img.data;
  for(let i=0;i<d.length;i+=4){
    const v = 210 + Math.random()*45;
    d[i]=v; d[i+1]=v; d[i+2]=v;
    d[i+3]=Math.round(255*strength*Math.random());
  }
  x.putImageData(img,0,0);
  return c;
}
function drawCover(c, img, x,y,w,h){
  const ir = img.width/img.height;
  const cr = w/h;
  let dw=w, dh=h, dx=x, dy=y;
  if(ir > cr){
    dh = h;
    dw = h*ir;
    dx = x - (dw - w)/2;
  }else{
    dw = w;
    dh = w/ir;
    dy = y - (dh - h)/2;
  }
  c.drawImage(img, dx, dy, dw, dh);
}
function fileToDataURL(file){
  return new Promise((res, rej)=>{
    const r = new FileReader();
    r.onload = ()=>res(r.result);
    r.onerror = rej;
    r.readAsDataURL(file);
  });
}
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function degToRad(d){ return d * Math.PI / 180; }

async function copyText(text, btn, label){
  const t = (text || "").trim();
  if(!t){ setStatus("Nothing to copy yet.", true); return; }
  try{
    await navigator.clipboard.writeText(t);
    const old = btn.textContent;
    btn.textContent = label || "Copied!";
    setTimeout(()=>btn.textContent = old, 800);
  }catch{
    alert(t);
  }
}
function setStatus(msg, isError){
  statusBox.innerHTML = `<b>Status:</b> ${escapeHtml(msg)}`;
  statusBox.style.borderColor = isError ? "rgba(198,90,46,.35)" : "rgba(231,220,207,1)";
  statusBox.style.background  = isError ? "rgba(198,90,46,.08)" : "rgba(255,255,255,.6)";
  statusBox.style.color       = isError ? "#6d2d17" : "var(--muted)";
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
}

function loadTextureMap(){
  try{ return JSON.parse(localStorage.getItem(KEYS.textures)) || {}; }catch{ return {}; }
}
function saveTextureMap(map){
  localStorage.setItem(KEYS.textures, JSON.stringify(map || {}));
}

/* =========================================================
   START
   ========================================================= */
renderTextureManager();
setOrient("t1","h");
setOrient("t2","h");
render();
setStatus("Ready. Click blank space to deselect. Text: side=width, corner=font size, curve=bend.", false);

iconSearch.value = "coffee";
iconSearchRun();
</script>
</body>
</html>
